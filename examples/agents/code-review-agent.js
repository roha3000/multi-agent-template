/**
 * Code Review Agent - Example agent for code review tasks
 *
 * Demonstrates:
 * - Specialized agent for code quality
 * - Critique pattern implementation
 * - Providing structured feedback
 */

const Agent = require('../../.claude/core/agent');

class CodeReviewAgent extends Agent {
  constructor(id, messageBus, config = {}) {
    super(id, 'Code Reviewer', messageBus, {
      timeout: 90000,
      retries: 2,
      ...config
    });

    this.focusAreas = config.focusAreas || [
      'code quality',
      'best practices',
      'security',
      'performance',
      'maintainability'
    ];
    this.severity = config.severity || 'balanced'; // lenient, balanced, strict
  }

  async execute(task, context = {}) {
    this.setState('working');
    const startTime = Date.now();

    try {
      this.logger.info('Starting code review', {
        taskType: task.type || task.phase,
        severity: this.severity
      });

      let result;

      // Handle different task types
      if (task.phase === 'review' || task.type === 'review') {
        result = await this._reviewCode(task);
      } else if (task.type === 'critique') {
        result = await this._critiqueProposal(task);
      } else if (task.phase === 'create') {
        result = await this._generateCodeSample(task);
      } else {
        result = await this._performGeneralReview(task);
      }

      const duration = Date.now() - startTime;
      this._recordExecution(task, result, duration);

      this.setState('completed');

      return {
        success: true,
        agentId: this.id,
        role: this.role,
        ...result
      };

    } catch (error) {
      this.logger.error('Code review failed', { error: error.message });
      this.setState('failed');

      const duration = Date.now() - startTime;
      this._recordExecution(task, { success: false, error: error.message }, duration);

      throw error;
    }
  }

  /**
   * Review code and provide feedback
   * @private
   */
  async _reviewCode(task) {
    await new Promise(resolve => setTimeout(resolve, 400));

    const { work, code } = task;
    const content = work || code || 'No code provided';

    const issues = this._identifyIssues(content);
    const suggestions = this._generateSuggestions(issues);

    return {
      review: `Code review by ${this.id}`,
      overallRating: this._calculateRating(issues),
      issues,
      suggestions,
      focusAreas: this.focusAreas,
      severity: this.severity,
      approvalStatus: issues.filter(i => i.severity === 'critical').length === 0 ? 'approved' : 'needs-changes'
    };
  }

  /**
   * Critique a proposal
   * @private
   */
  async _critiqueProposal(task) {
    await new Promise(resolve => setTimeout(resolve, 300));

    const { proposal, round } = task;

    return {
      critique: `Critique from ${this.id} (Round ${round || 1}): The proposal "${proposal}" has merit but could be improved.`,
      strengths: [
        'Clear problem statement',
        'Addresses key concerns',
        'Feasible approach'
      ],
      weaknesses: [
        'Could be more specific in implementation details',
        'Missing edge case considerations',
        'Performance implications not addressed'
      ],
      suggestions: [
        'Add concrete examples',
        'Consider scalability',
        'Include error handling strategy',
        'Document assumptions clearly'
      ],
      priority: 'medium',
      confidence: 0.8
    };
  }

  /**
   * Generate code sample for demonstration
   * @private
   */
  async _generateCodeSample(task) {
    await new Promise(resolve => setTimeout(resolve, 500));

    return {
      work: `// Code sample generated by ${this.id}\n` +
        `function example() {\n` +
        `  // Implementation here\n` +
        `  return { success: true };\n` +
        `}`,
      language: 'javascript',
      quality: 'production-ready',
      testCoverage: 0.85
    };
  }

  /**
   * Perform general review
   * @private
   */
  async _performGeneralReview(task) {
    await new Promise(resolve => setTimeout(resolve, 350));

    return {
      review: `General code review completed by ${this.id}`,
      summary: 'Code meets acceptable standards with minor improvements needed',
      score: 75,
      recommendations: [
        'Add inline documentation',
        'Improve error handling',
        'Consider refactoring complex functions'
      ]
    };
  }

  /**
   * Identify issues in code
   * @private
   */
  _identifyIssues(content) {
    const issues = [];

    // Simulate issue detection based on severity setting
    const issueCount = this.severity === 'strict' ? 5 : this.severity === 'balanced' ? 3 : 1;

    const possibleIssues = [
      { type: 'style', severity: 'minor', description: 'Inconsistent indentation' },
      { type: 'performance', severity: 'medium', description: 'Potential optimization opportunity' },
      { type: 'security', severity: 'high', description: 'Input validation needed' },
      { type: 'maintainability', severity: 'medium', description: 'Complex function could be split' },
      { type: 'documentation', severity: 'low', description: 'Missing JSDoc comments' }
    ];

    return possibleIssues.slice(0, issueCount);
  }

  /**
   * Generate suggestions based on issues
   * @private
   */
  _generateSuggestions(issues) {
    return issues.map(issue => ({
      issue: issue.description,
      suggestion: `Fix: ${issue.description} by applying best practices`,
      priority: issue.severity
    }));
  }

  /**
   * Calculate overall rating
   * @private
   */
  _calculateRating(issues) {
    const baseLine = 100;
    const deductions = {
      'critical': 30,
      'high': 15,
      'medium': 10,
      'low': 5,
      'minor': 2
    };

    let score = baseLine;
    issues.forEach(issue => {
      score -= deductions[issue.severity] || 5;
    });

    return Math.max(score, 0);
  }
}

module.exports = CodeReviewAgent;
