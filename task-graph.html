<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Task Dependency Graph</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #0f172a;
      color: #e2e8f0;
      overflow: hidden;
    }

    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #1e293b;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      border-bottom: 1px solid #334155;
    }

    .header h1 {
      font-size: 18px;
      font-weight: 600;
    }

    .header .stats {
      display: flex;
      gap: 20px;
      font-size: 13px;
      color: #94a3b8;
    }

    .header .stats span {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .header .stats .count {
      color: #f1f5f9;
      font-weight: 600;
    }

    #graph-container {
      width: 100vw;
      height: 100vh;
      padding-top: 56px;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    .node {
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .node:hover {
      opacity: 0.8;
    }

    .node-label {
      font-size: 11px;
      fill: #f1f5f9;
      pointer-events: none;
      text-anchor: middle;
    }

    .link {
      stroke-opacity: 0.6;
      fill: none;
    }

    .link.requires {
      stroke: #64748b;
      stroke-width: 2;
    }

    .link.blocks {
      stroke: #ef4444;
      stroke-width: 2;
    }

    .link.related {
      stroke: #475569;
      stroke-width: 1;
      stroke-dasharray: 4,4;
    }

    .arrow {
      fill: #64748b;
    }

    .arrow.blocks {
      fill: #ef4444;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 12px;
      font-size: 13px;
      max-width: 300px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 1000;
    }

    .tooltip.visible {
      opacity: 1;
    }

    .tooltip h3 {
      font-size: 14px;
      margin-bottom: 8px;
      color: #f1f5f9;
    }

    .tooltip .status {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .tooltip .status.completed { background: #166534; color: #bbf7d0; }
    .tooltip .status.in_progress { background: #1d4ed8; color: #bfdbfe; }
    .tooltip .status.ready { background: #b45309; color: #fef3c7; }
    .tooltip .status.blocked { background: #b91c1c; color: #fecaca; }
    .tooltip .status.pending { background: #374151; color: #d1d5db; }

    .tooltip .meta {
      color: #94a3b8;
      font-size: 12px;
      margin-bottom: 4px;
    }

    .tooltip .tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 8px;
    }

    .tooltip .tag {
      background: #334155;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 11px;
      color: #94a3b8;
    }

    /* Legend */
    .legend {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 12px;
      font-size: 12px;
    }

    .legend h4 {
      margin-bottom: 8px;
      color: #94a3b8;
      font-weight: 500;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .legend-line {
      width: 20px;
      height: 2px;
    }

    /* Controls */
    .controls {
      position: fixed;
      top: 70px;
      right: 20px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 12px;
    }

    .controls button {
      background: #334155;
      border: none;
      color: #e2e8f0;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin: 2px;
      transition: background 0.2s;
    }

    .controls button:hover {
      background: #475569;
    }

    /* Critical path highlight */
    .critical-path {
      stroke: #fbbf24 !important;
      stroke-width: 3 !important;
    }

    .critical-node {
      stroke: #fbbf24;
      stroke-width: 3;
    }

    /* Blocked task highlighting */
    .node.blocked-highlight {
      stroke: #ef4444;
      stroke-width: 4;
      animation: pulse-blocked 1.5s infinite;
    }

    @keyframes pulse-blocked {
      0%, 100% { filter: drop-shadow(0 0 4px rgba(239, 68, 68, 0.6)); }
      50% { filter: drop-shadow(0 0 12px rgba(239, 68, 68, 0.9)); }
    }

    .link.blocking-chain {
      stroke: #f97316 !important;
      stroke-width: 3 !important;
      stroke-opacity: 1 !important;
      animation: pulse-link 1s infinite;
    }

    @keyframes pulse-link {
      0%, 100% { stroke-opacity: 0.8; }
      50% { stroke-opacity: 1; }
    }

    .node.dependency-highlight {
      stroke: #f97316;
      stroke-width: 3;
      filter: drop-shadow(0 0 6px rgba(249, 115, 22, 0.7));
    }

    .node.dim {
      opacity: 0.25;
    }

    .link.dim {
      stroke-opacity: 0.1;
    }

    /* Blocked tasks panel */
    .blocked-panel {
      position: fixed;
      top: 70px;
      left: 20px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 12px;
      max-width: 280px;
      max-height: 400px;
      overflow-y: auto;
      display: none;
    }

    .blocked-panel.visible {
      display: block;
    }

    .blocked-panel h4 {
      margin-bottom: 10px;
      color: #f1f5f9;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .blocked-panel h4 .badge {
      background: #ef4444;
      color: white;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 11px;
    }

    .blocked-item {
      background: #0f172a;
      border: 1px solid #334155;
      border-left: 3px solid #ef4444;
      border-radius: 4px;
      padding: 8px 10px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .blocked-item:hover {
      background: #1e293b;
      border-color: #ef4444;
    }

    .blocked-item .title {
      font-size: 12px;
      color: #f1f5f9;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .blocked-item .blocker {
      font-size: 11px;
      color: #94a3b8;
    }

    .blocked-item .blocker-name {
      color: #f97316;
    }

    /* Filter controls */
    .filter-group {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #334155;
    }

    .filter-btn {
      background: #334155;
      border: none;
      color: #e2e8f0;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      margin: 2px;
      transition: all 0.2s;
    }

    .filter-btn:hover {
      background: #475569;
    }

    .filter-btn.active {
      background: #ef4444;
      color: white;
    }

    .controls-expanded {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Task Dependency Graph</h1>
    <div class="stats">
      <span>Tasks: <span class="count" id="task-count">0</span></span>
      <span>Dependencies: <span class="count" id="dep-count">0</span></span>
      <span>Completed: <span class="count" id="completed-count">0</span></span>
      <span>Blocked: <span class="count" id="blocked-count">0</span></span>
    </div>
  </div>

  <div id="graph-container">
    <svg></svg>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <div class="legend">
    <h4>Status</h4>
    <div class="legend-item">
      <div class="legend-color" style="background: #22c55e;"></div>
      <span>Completed</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #3b82f6;"></div>
      <span>In Progress</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #f59e0b;"></div>
      <span>Ready</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #ef4444;"></div>
      <span>Blocked</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #6b7280;"></div>
      <span>Pending</span>
    </div>
    <h4 style="margin-top: 12px;">Links</h4>
    <div class="legend-item">
      <div class="legend-line" style="background: #64748b;"></div>
      <span>Requires</span>
    </div>
    <div class="legend-item">
      <div class="legend-line" style="background: #ef4444;"></div>
      <span>Blocks</span>
    </div>
    <div class="legend-item">
      <div class="legend-line" style="background: #475569; border-style: dashed;"></div>
      <span>Related</span>
    </div>
  </div>

  <div class="controls controls-expanded">
    <button onclick="resetZoom()">Reset View</button>
    <button onclick="toggleCriticalPath()">Show Critical Path</button>
    <button onclick="refreshData()">Refresh</button>
    <div class="filter-group">
      <button class="filter-btn" id="filter-blocked" onclick="toggleBlockedFilter()">Show Blocked Only</button>
      <button class="filter-btn" id="toggle-panel" onclick="toggleBlockedPanel()">Blocked Panel</button>
    </div>
  </div>

  <div class="blocked-panel" id="blocked-panel">
    <h4>Blocked Tasks <span class="badge" id="blocked-badge">0</span></h4>
    <div id="blocked-list"></div>
  </div>

  <script>
    // Graph state
    let graphData = { nodes: [], links: [] };
    let simulation = null;
    let showingCriticalPath = false;
    let criticalPath = [];
    let showingBlockedOnly = false;
    let selectedBlockedTask = null;
    let blockedTasks = [];
    let dependencyMap = new Map(); // Maps task ID to its dependencies

    // SVG setup
    const svg = d3.select('svg');
    const container = svg.append('g');

    // Arrow markers
    svg.append('defs').selectAll('marker')
      .data(['requires', 'blocks'])
      .join('marker')
      .attr('id', d => `arrow-${d}`)
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 20)
      .attr('refY', 0)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('class', d => `arrow ${d}`);

    // Zoom behavior
    const zoom = d3.zoom()
      .scaleExtent([0.2, 4])
      .on('zoom', (event) => {
        container.attr('transform', event.transform);
      });

    svg.call(zoom);

    // Tooltip
    const tooltip = d3.select('#tooltip');

    // Load and render data
    async function loadData() {
      try {
        const response = await fetch('/api/tasks/graph');
        const data = await response.json();
        graphData = data.graph;
        criticalPath = data.statistics?.criticalPath || [];
        renderGraph();
        updateStats(data.statistics);
      } catch (err) {
        console.error('Failed to load graph data:', err);
        // Try to load from tasks.json directly
        loadFromTasksJson();
      }
    }

    async function loadFromTasksJson() {
      try {
        const response = await fetch('/tasks.json');
        const data = await response.json();
        graphData = transformTasksToGraph(data);
        renderGraph();
        updateStatsFromGraph();
      } catch (err) {
        console.error('Failed to load tasks.json:', err);
      }
    }

    function transformTasksToGraph(tasksData) {
      const nodes = [];
      const links = [];

      const tasks = tasksData.tasks || {};
      const taskIds = Object.keys(tasks);

      // Create nodes
      for (const id of taskIds) {
        const task = tasks[id];
        nodes.push({
          id: task.id,
          title: task.title,
          status: task.status,
          priority: task.priority,
          phase: task.phase,
          estimate: task.estimate,
          tags: task.tags || [],
          radius: task.priority === 'high' ? 20 : task.priority === 'medium' ? 15 : 10,
          color: getStatusColor(task.status),
        });
      }

      // Create links
      for (const id of taskIds) {
        const task = tasks[id];
        if (task.depends) {
          if (task.depends.requires) {
            for (const reqId of task.depends.requires) {
              if (tasks[reqId]) {
                links.push({ source: reqId, target: id, type: 'requires' });
              }
            }
          }
          if (task.depends.blocks) {
            for (const blockId of task.depends.blocks) {
              if (tasks[blockId]) {
                links.push({ source: id, target: blockId, type: 'blocks' });
              }
            }
          }
        }
      }

      return { nodes, links };
    }

    function getStatusColor(status) {
      const colors = {
        completed: '#22c55e',
        in_progress: '#3b82f6',
        ready: '#f59e0b',
        blocked: '#ef4444',
        pending: '#6b7280',
      };
      return colors[status] || '#9ca3af';
    }

    function renderGraph() {
      const width = window.innerWidth;
      const height = window.innerHeight - 56;

      // Clear existing
      container.selectAll('*').remove();

      // Create simulation
      simulation = d3.forceSimulation(graphData.nodes)
        .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(120))
        .force('charge', d3.forceManyBody().strength(-300))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(d => d.radius + 20));

      // Draw links
      const link = container.append('g')
        .selectAll('line')
        .data(graphData.links)
        .join('line')
        .attr('class', d => `link ${d.type}`)
        .attr('marker-end', d => d.type !== 'related' ? `url(#arrow-${d.type})` : null);

      // Draw nodes
      const node = container.append('g')
        .selectAll('circle')
        .data(graphData.nodes)
        .join('circle')
        .attr('class', 'node')
        .attr('r', d => d.radius)
        .attr('fill', d => d.color)
        .call(drag(simulation))
        .on('mouseover', showTooltip)
        .on('mouseout', hideTooltip)
        .on('click', handleNodeClick);

      // Draw labels
      const label = container.append('g')
        .selectAll('text')
        .data(graphData.nodes)
        .join('text')
        .attr('class', 'node-label')
        .attr('dy', d => d.radius + 14)
        .text(d => truncate(d.title, 20));

      // Update positions on tick
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        node
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);

        label
          .attr('x', d => d.x)
          .attr('y', d => d.y);
      });

      // Build dependency map and update blocked tasks panel
      buildDependencyMap();
      updateBlockedTasksList();
    }

    function drag(simulation) {
      function dragstarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      }

      function dragged(event) {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      }

      function dragended(event) {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      }

      return d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended);
    }

    function showTooltip(event, d) {
      const html = `
        <h3>${d.title}</h3>
        <span class="status ${d.status}">${d.status.replace('_', ' ')}</span>
        <div class="meta">Phase: ${d.phase || 'N/A'}</div>
        <div class="meta">Priority: ${d.priority || 'N/A'}</div>
        <div class="meta">Estimate: ${d.estimate || 'N/A'}</div>
        ${d.tags.length ? `<div class="tags">${d.tags.map(t => `<span class="tag">${t}</span>`).join('')}</div>` : ''}
      `;

      tooltip
        .html(html)
        .style('left', (event.pageX + 15) + 'px')
        .style('top', (event.pageY - 10) + 'px')
        .classed('visible', true);
    }

    function hideTooltip() {
      tooltip.classed('visible', false);
    }

    function handleNodeClick(event, d) {
      console.log('Clicked:', d);
      event.stopPropagation();

      // If clicking on a blocked task, show its blocking chain
      if (d.status === 'blocked') {
        focusOnBlockedTask(d.id);
      } else {
        // Clear selection if clicking non-blocked node
        selectedBlockedTask = null;
        clearHighlights();
      }
    }

    // Clear selection when clicking on background
    svg.on('click', () => {
      selectedBlockedTask = null;
      clearHighlights();
    });

    function updateStats(stats) {
      if (!stats) return;
      document.getElementById('task-count').textContent = stats.totalNodes || 0;
      document.getElementById('dep-count').textContent = stats.totalLinks || 0;
      document.getElementById('completed-count').textContent = stats.statusCounts?.completed || 0;
      document.getElementById('blocked-count').textContent = stats.statusCounts?.blocked || 0;
    }

    function updateStatsFromGraph() {
      const stats = {
        totalNodes: graphData.nodes.length,
        totalLinks: graphData.links.length,
        statusCounts: {}
      };
      for (const node of graphData.nodes) {
        stats.statusCounts[node.status] = (stats.statusCounts[node.status] || 0) + 1;
      }
      updateStats(stats);
    }

    function resetZoom() {
      svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
    }

    function toggleCriticalPath() {
      showingCriticalPath = !showingCriticalPath;
      // This would highlight the critical path - for now just log
      console.log('Critical path:', criticalPath);
    }

    // Build dependency map for finding blocking chains
    function buildDependencyMap() {
      dependencyMap.clear();
      for (const node of graphData.nodes) {
        dependencyMap.set(node.id, { requires: [], blocks: [], blockedBy: [] });
      }
      for (const link of graphData.links) {
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
        if (link.type === 'requires') {
          // sourceId is required BY targetId
          dependencyMap.get(targetId)?.requires.push(sourceId);
          dependencyMap.get(sourceId)?.blocks.push(targetId);
        } else if (link.type === 'blocks') {
          dependencyMap.get(sourceId)?.blocks.push(targetId);
          dependencyMap.get(targetId)?.blockedBy.push(sourceId);
        }
      }
    }

    // Find the blocking chain for a task (what tasks are blocking it)
    function findBlockingChain(taskId, visited = new Set()) {
      if (visited.has(taskId)) return [];
      visited.add(taskId);

      const deps = dependencyMap.get(taskId);
      if (!deps) return [taskId];

      const chain = [taskId];
      const node = graphData.nodes.find(n => n.id === taskId);

      // Look at required tasks that aren't completed
      for (const reqId of deps.requires) {
        const reqNode = graphData.nodes.find(n => n.id === reqId);
        if (reqNode && reqNode.status !== 'completed') {
          chain.push(...findBlockingChain(reqId, visited));
        }
      }

      return chain;
    }

    // Update blocked tasks list
    function updateBlockedTasksList() {
      blockedTasks = graphData.nodes.filter(n => n.status === 'blocked');
      const listEl = document.getElementById('blocked-list');
      const badgeEl = document.getElementById('blocked-badge');

      badgeEl.textContent = blockedTasks.length;

      if (blockedTasks.length === 0) {
        listEl.innerHTML = '<div style="color: #94a3b8; font-size: 12px;">No blocked tasks</div>';
        return;
      }

      listEl.innerHTML = blockedTasks.map(task => {
        const deps = dependencyMap.get(task.id);
        const blockers = (deps?.requires || [])
          .map(id => graphData.nodes.find(n => n.id === id))
          .filter(n => n && n.status !== 'completed');

        const blockerText = blockers.length > 0
          ? `Blocked by: <span class="blocker-name">${blockers.map(b => truncate(b.title, 15)).join(', ')}</span>`
          : 'No active blockers';

        return `
          <div class="blocked-item" onclick="focusOnBlockedTask('${task.id}')"
               onmouseenter="highlightBlockingChain('${task.id}')"
               onmouseleave="clearHighlights()">
            <div class="title">${task.title}</div>
            <div class="blocker">${blockerText}</div>
          </div>
        `;
      }).join('');
    }

    // Focus on a blocked task and show its dependency chain
    function focusOnBlockedTask(taskId) {
      selectedBlockedTask = taskId;

      // Find the node position
      const node = graphData.nodes.find(n => n.id === taskId);
      if (!node) return;

      // Zoom to the node
      const scale = 1.5;
      const x = window.innerWidth / 2 - node.x * scale;
      const y = window.innerHeight / 2 - node.y * scale;

      svg.transition()
        .duration(500)
        .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));

      // Highlight the blocking chain
      highlightBlockingChain(taskId);
    }

    // Highlight the blocking chain for a task
    function highlightBlockingChain(taskId) {
      const chain = findBlockingChain(taskId);
      const chainSet = new Set(chain);

      // Dim all nodes and links not in chain
      container.selectAll('circle.node')
        .classed('dim', d => !chainSet.has(d.id))
        .classed('blocked-highlight', d => d.id === taskId)
        .classed('dependency-highlight', d => chainSet.has(d.id) && d.id !== taskId);

      container.selectAll('line.link')
        .classed('dim', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          return !chainSet.has(sourceId) || !chainSet.has(targetId);
        })
        .classed('blocking-chain', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          return chainSet.has(sourceId) && chainSet.has(targetId);
        });

      container.selectAll('text.node-label')
        .classed('dim', d => !chainSet.has(d.id));
    }

    // Clear all highlights
    function clearHighlights() {
      if (selectedBlockedTask) return; // Keep highlights if task is selected

      container.selectAll('circle.node')
        .classed('dim', false)
        .classed('blocked-highlight', false)
        .classed('dependency-highlight', false);

      container.selectAll('line.link')
        .classed('dim', false)
        .classed('blocking-chain', false);

      container.selectAll('text.node-label')
        .classed('dim', false);
    }

    // Toggle blocked tasks filter
    function toggleBlockedFilter() {
      showingBlockedOnly = !showingBlockedOnly;
      const btn = document.getElementById('filter-blocked');
      btn.classList.toggle('active', showingBlockedOnly);

      if (showingBlockedOnly) {
        // Show only blocked tasks and their dependencies
        const blockedIds = new Set(blockedTasks.map(t => t.id));
        const relevantIds = new Set(blockedIds);

        // Add blocking dependencies
        for (const id of blockedIds) {
          const chain = findBlockingChain(id);
          chain.forEach(cid => relevantIds.add(cid));
        }

        container.selectAll('circle.node')
          .classed('dim', d => !relevantIds.has(d.id));

        container.selectAll('line.link')
          .classed('dim', d => {
            const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
            const targetId = typeof d.target === 'object' ? d.target.id : d.target;
            return !relevantIds.has(sourceId) || !relevantIds.has(targetId);
          });

        container.selectAll('text.node-label')
          .classed('dim', d => !relevantIds.has(d.id));
      } else {
        clearHighlights();
        selectedBlockedTask = null;
      }
    }

    // Toggle blocked panel visibility
    function toggleBlockedPanel() {
      const panel = document.getElementById('blocked-panel');
      const btn = document.getElementById('toggle-panel');
      panel.classList.toggle('visible');
      btn.classList.toggle('active', panel.classList.contains('visible'));
    }

    function refreshData() {
      loadData();
    }

    function truncate(str, len) {
      return str.length > len ? str.substring(0, len) + '...' : str;
    }

    // Handle resize
    window.addEventListener('resize', () => {
      if (simulation) {
        simulation.force('center', d3.forceCenter(window.innerWidth / 2, (window.innerHeight - 56) / 2));
        simulation.alpha(0.3).restart();
      }
    });

    // Initial load
    loadData();

    // Auto-refresh every 30 seconds
    setInterval(refreshData, 30000);
  </script>
</body>
</html>
