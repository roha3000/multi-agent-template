<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fleet Dashboard v4</title>
  <style>
    :root {
      /* Dark theme - GitHub style */
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #21262d;
      --bg-hover: #30363d;
      --border-color: #30363d;
      --border-muted: #21262d;

      /* Text colors */
      --text-primary: #e6edf3;
      --text-secondary: #8b949e;
      --text-muted: #6e7681;

      /* Status colors */
      --color-success: #3fb950;
      --color-warning: #d29922;
      --color-danger: #f85149;
      --color-info: #58a6ff;
      --color-purple: #a371f7;

      /* Quality thresholds */
      --quality-excellent: #3fb950;  /* 85+ */
      --quality-good: #3fb950;       /* 75-84 */
      --quality-warning: #d29922;    /* 50-74 */
      --quality-critical: #f85149;   /* <50 */
      --quality-idle: #6e7681;

      /* Layout */
      --sidebar-width: 340px;
      --header-height: 48px;
      --status-bar-height: 40px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.5;
      overflow-y: auto;
      min-height: 100vh;
    }

    /* ===== LAYOUT ===== */
    .app-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    .header {
      height: var(--header-height);
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      flex-shrink: 0;
    }

    .header h1 {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header h1 .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--color-success);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .header-actions {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .header-btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .header-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    /* ===== TRAFFIC LIGHT STATUS BAR ===== */
    .status-bar {
      height: var(--status-bar-height);
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 16px;
      flex-shrink: 0;
    }

    .status-bar-label {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .traffic-lights {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .traffic-light {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
      position: relative;
    }

    .traffic-light:hover {
      transform: scale(1.2);
    }

    .traffic-light.excellent { background: var(--quality-excellent); box-shadow: 0 0 8px var(--quality-excellent); }
    .traffic-light.good { background: var(--quality-good); }
    .traffic-light.warning { background: var(--quality-warning); box-shadow: 0 0 8px var(--quality-warning); }
    .traffic-light.critical { background: var(--quality-critical); box-shadow: 0 0 8px var(--quality-critical); animation: blink 1s infinite; }
    .traffic-light.idle { background: var(--quality-idle); }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .traffic-light-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      white-space: nowrap;
      display: none;
      z-index: 100;
    }

    .traffic-light:hover .traffic-light-tooltip {
      display: block;
    }

    .status-summary {
      font-size: 12px;
      color: var(--text-secondary);
      margin-left: auto;
    }

    .usage-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      background: var(--bg-tertiary);
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      cursor: pointer;
    }

    .usage-badge:hover {
      background: var(--bg-hover);
    }

    .usage-badge .bar {
      width: 60px;
      height: 4px;
      background: var(--bg-hover);
      border-radius: 2px;
      overflow: hidden;
    }

    .usage-badge .bar-fill {
      height: 100%;
      background: var(--color-success);
      transition: width 0.3s, background 0.3s;
    }

    .usage-badge .bar-fill.warning { background: var(--color-warning); }
    .usage-badge .bar-fill.critical { background: var(--color-danger); }

    /* ===== FLEET MANAGEMENT HEADER ===== */
    .fleet-header {
      background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
      border-bottom: 1px solid var(--border-color);
      padding: 8px 16px;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      align-items: center;
    }

    .fleet-metric-card {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 16px;
    }

    .fleet-metric-card h3 {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .fleet-countdown {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .countdown-time {
      font-size: 24px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }

    .countdown-time.warning { color: var(--color-warning); }
    .countdown-time.critical { color: var(--color-danger); }

    .countdown-bar {
      flex: 1;
      height: 6px;
      background: var(--bg-hover);
      border-radius: 3px;
      overflow: hidden;
    }

    .countdown-bar-fill {
      height: 100%;
      background: var(--color-success);
      transition: width 0.5s ease, background 0.3s;
    }

    .countdown-bar-fill.warning { background: var(--color-warning); }
    .countdown-bar-fill.critical { background: var(--color-danger); }

    .fleet-stats {
      display: flex;
      gap: 12px;
    }

    .fleet-stat {
      text-align: center;
    }

    .fleet-stat-value {
      font-size: 20px;
      font-weight: 700;
      line-height: 1.2;
    }

    .fleet-stat-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .fleet-stat-value.active { color: var(--color-success); }
    .fleet-stat-value.warning { color: var(--color-warning); }
    .fleet-stat-value.critical { color: var(--color-danger); }

    /* ===== ALERT BANNER ===== */
    .alert-banner {
      display: none;  /* Hidden by default, shown via .visible class */
      background: var(--color-danger);
      color: white;
      padding: 8px 20px;
      align-items: center;
      justify-content: space-between;
      font-size: 13px;
      font-weight: 500;
    }

    .alert-banner.warning {
      background: var(--color-warning);
      color: #1a1a1a;
    }

    .alert-banner.visible {
      display: flex;
    }

    .alert-banner-message {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .alert-banner-actions {
      display: flex;
      gap: 8px;
    }

    .alert-banner-btn {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: inherit;
      padding: 4px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .alert-banner-btn:hover {
      background: rgba(255,255,255,0.3);
    }

    /* ===== TOAST NOTIFICATIONS ===== */
    .toast-container {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: none;
    }

    .toast {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 16px;
      min-width: 280px;
      max-width: 360px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      pointer-events: auto;
      animation: slideIn 0.3s ease;
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }

    .toast.success { border-left: 3px solid var(--color-success); }
    .toast.warning { border-left: 3px solid var(--color-warning); }
    .toast.error { border-left: 3px solid var(--color-danger); }
    .toast.info { border-left: 3px solid var(--color-info); }

    .toast-icon {
      font-size: 16px;
      flex-shrink: 0;
    }

    .toast-content {
      flex: 1;
    }

    .toast-title {
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 2px;
    }

    .toast-message {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .toast-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 16px;
      padding: 0;
      line-height: 1;
    }

    .toast-close:hover {
      color: var(--text-primary);
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(100%);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* ===== PROJECT CARDS (Fleet View) ===== */
    .project-cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px;
      padding: 12px 16px;
    }

    .project-cards:empty {
      display: none;  /* Collapse when no active projects */
      padding: 0;
    }

    .project-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .project-card-header {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .project-card-title {
      font-weight: 600;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .project-health-dots {
      display: flex;
      gap: 3px;
    }

    .project-health-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--color-success);
    }

    .project-health-dot.empty {
      background: var(--bg-hover);
    }

    .project-card-body {
      padding: 8px 12px;
    }

    .project-task-list {
      margin-bottom: 8px;
    }

    .project-task-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
      font-size: 12px;
      border-bottom: 1px solid var(--border-muted);
    }

    .project-task-item:last-child {
      border-bottom: none;
    }

    .project-task-status {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }

    .project-task-status.active { background: var(--color-success); }
    .project-task-status.pending { background: var(--text-muted); }
    .project-task-status.completed { background: var(--color-info); }

    .project-task-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .project-task-progress {
      color: var(--text-muted);
      font-size: 11px;
    }

    .project-card-footer {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .project-expand-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 11px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .project-expand-btn:hover {
      color: var(--text-primary);
    }

    /* ===== AGENT LINEAGE TREE ===== */
    .agent-lineage-tree {
      padding: 16px;
      font-family: monospace;
      font-size: 12px;
      line-height: 1.6;
    }

    .agent-node {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 4px 0;
    }

    .agent-node-prefix {
      color: var(--text-muted);
      flex-shrink: 0;
    }

    .agent-node-content {
      flex: 1;
    }

    .agent-node-header {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .agent-node-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .agent-node-status.active { background: var(--color-success); }
    .agent-node-status.idle { background: var(--text-muted); }
    .agent-node-status.error { background: var(--color-danger); }

    .agent-node-id {
      font-weight: 600;
      color: var(--text-primary);
    }

    .agent-node-meta {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* ===== FLEET LINEAGE PANEL ===== */
    .fleet-lineage-panel {
      display: none;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      max-height: 300px;
      overflow: hidden;
    }

    .fleet-lineage-panel.visible {
      display: block;
    }

    .fleet-lineage-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
    }

    .fleet-lineage-header h3 {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .fleet-lineage-actions {
      display: flex;
      gap: 4px;
    }

    .fleet-lineage-btn {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fleet-lineage-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .fleet-lineage-content {
      padding: 12px 16px;
      overflow-y: auto;
      max-height: 250px;
    }

    .fleet-lineage-empty {
      color: var(--text-muted);
      font-size: 12px;
      text-align: center;
      padding: 20px;
    }

    .lineage-tree {
      font-family: monospace;
      font-size: 12px;
      line-height: 1.8;
    }

    .lineage-node {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 2px 0;
      cursor: pointer;
    }

    .lineage-node:hover {
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    .lineage-node-prefix {
      color: var(--text-muted);
      user-select: none;
    }

    .lineage-node-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .lineage-node-status.active { background: var(--color-success); animation: pulse 2s infinite; }
    .lineage-node-status.idle { background: var(--text-muted); }
    .lineage-node-status.completed { background: var(--color-info); }
    .lineage-node-status.error { background: var(--color-danger); }

    .lineage-node-label {
      color: var(--text-primary);
      font-weight: 500;
    }

    .lineage-node-meta {
      color: var(--text-muted);
      font-size: 11px;
      margin-left: auto;
    }

    .lineage-node-children {
      margin-left: 20px;
    }

    .lineage-node-children.collapsed {
      display: none;
    }

    /* View Lineage button in fleet header */
    .fleet-view-lineage-btn {
      background: var(--bg-primary);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .fleet-view-lineage-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .fleet-view-lineage-btn.active {
      background: var(--color-info);
      color: white;
      border-color: var(--color-info);
    }

    /* ===== MAIN CONTENT (SPLIT PANE) ===== */
    .main-content {
      flex: 1;
      display: flex;
      overflow: hidden;
      min-height: 0;  /* Allow flex children to shrink below content size */
    }

    /* ===== SESSION LIST (LEFT PANE) ===== */
    .session-list {
      width: var(--sidebar-width);
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .session-list-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .session-filters {
      display: flex;
      gap: 8px;
      padding: 6px 12px;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      flex-wrap: wrap;
    }

    .filter-checkbox {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--text-muted);
      cursor: pointer;
    }

    .filter-checkbox input[type="checkbox"] {
      width: 12px;
      height: 12px;
      margin: 0;
      cursor: pointer;
    }

    .filter-checkbox:hover {
      color: var(--text-primary);
    }

    .session-group {
      border-bottom: 1px solid var(--border-color);
    }

    .session-group-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .session-group-header:hover {
      background: var(--bg-secondary);
    }

    .session-group-toggle {
      font-size: 10px;
      transition: transform 0.2s;
    }

    .session-group.collapsed .session-group-toggle {
      transform: rotate(-90deg);
    }

    .session-group.collapsed .session-group-items {
      display: none;
    }

    .session-group-count {
      color: var(--text-muted);
      font-weight: normal;
    }

    .session-type-badge {
      font-size: 9px;
      padding: 1px 4px;
      border-radius: 3px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .session-type-badge.cli {
      background: var(--color-info);
      color: white;
    }

    .session-type-badge.autonomous {
      background: var(--color-warning);
      color: #1a1a1a;
    }

    .session-id-text {
      font-size: 9px;
      color: var(--text-muted);
      font-family: monospace;
    }

    .session-list-header h2 {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--text-muted);
      letter-spacing: 0.5px;
    }

    .session-count {
      font-size: 11px;
      background: var(--bg-tertiary);
      padding: 2px 8px;
      border-radius: 10px;
      color: var(--text-secondary);
    }

    .session-items {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .session-item {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
    }

    .session-item:hover {
      border-color: var(--color-info);
      background: var(--bg-hover);
    }

    .session-item.selected {
      border-color: var(--color-info);
      background: rgba(88, 166, 255, 0.1);
    }

    .session-item.warning {
      border-left: 3px solid var(--color-warning);
    }

    .session-item.critical {
      border-left: 3px solid var(--color-danger);
    }

    .session-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .session-name {
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .session-name .autonomous-badge {
      font-size: 12px;
    }

    .quality-badge {
      font-size: 12px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 10px;
      min-width: 36px;
      text-align: center;
    }

    .quality-badge.excellent { background: rgba(63, 185, 80, 0.2); color: var(--quality-excellent); }
    .quality-badge.good { background: rgba(63, 185, 80, 0.15); color: var(--quality-good); }
    .quality-badge.warning { background: rgba(210, 153, 34, 0.2); color: var(--quality-warning); }
    .quality-badge.critical { background: rgba(248, 81, 73, 0.2); color: var(--quality-critical); }
    .quality-badge.idle { background: var(--bg-hover); color: var(--text-muted); }

    .session-task {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .phase-badge {
      font-size: 10px;
      text-transform: uppercase;
      padding: 2px 6px;
      border-radius: 4px;
      background: var(--bg-hover);
      color: var(--text-muted);
    }

    .phase-badge.research { background: rgba(163, 113, 247, 0.2); color: var(--color-purple); }
    .phase-badge.design { background: rgba(88, 166, 255, 0.2); color: var(--color-info); }
    .phase-badge.implement { background: rgba(63, 185, 80, 0.2); color: var(--color-success); }
    .phase-badge.test { background: rgba(210, 153, 34, 0.2); color: var(--color-warning); }

    /* Phase Progression Indicator */
    .phase-progression {
      display: flex;
      align-items: center;
      gap: 4px;
      margin: 8px 0;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border-radius: 6px;
    }

    .phase-step {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .phase-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .phase-dot.pending {
      background: var(--bg-hover);
      color: var(--text-muted);
      border: 2px solid var(--border-color);
    }

    .phase-dot.current {
      background: var(--color-info);
      color: white;
      border: 2px solid var(--color-info);
      animation: pulse 2s infinite;
    }

    .phase-dot.completed {
      background: var(--color-success);
      color: white;
      border: 2px solid var(--color-success);
    }

    .phase-label {
      font-size: 9px;
      text-transform: uppercase;
      color: var(--text-muted);
      letter-spacing: 0.5px;
    }

    .phase-label.current {
      color: var(--color-info);
      font-weight: 600;
    }

    .phase-label.completed {
      color: var(--color-success);
    }

    .phase-connector {
      width: 20px;
      height: 2px;
      background: var(--border-color);
    }

    .phase-connector.completed {
      background: var(--color-success);
    }

    .phase-score {
      font-size: 8px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(88, 166, 255, 0.4); }
      50% { box-shadow: 0 0 0 6px rgba(88, 166, 255, 0); }
    }

    .session-metrics {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .session-metrics span {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .session-controls {
      display: flex;
      gap: 6px;
    }

    .control-btn {
      flex: 1;
      padding: 6px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.15s;
    }

    .control-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .control-btn.pause:hover { border-color: var(--color-warning); color: var(--color-warning); }
    .control-btn.skip:hover { border-color: var(--color-info); color: var(--color-info); }
    .control-btn.end:hover { border-color: var(--color-danger); color: var(--color-danger); }

    .control-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      background: var(--bg-tertiary);
    }
    .control-btn:disabled:hover {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border-color: var(--border-color);
    }

    /* ===== DETAIL PANEL (RIGHT PANE) ===== */
    .detail-panel {
      flex: 1;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .detail-empty {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      font-size: 14px;
    }

    .detail-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .detail-title {
      font-size: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .detail-actions {
      display: flex;
      gap: 8px;
    }

    .detail-btn {
      padding: 8px 16px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
    }

    .detail-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .detail-btn.primary {
      background: var(--color-info);
      border-color: var(--color-info);
      color: white;
    }

    .detail-btn.danger {
      border-color: var(--color-danger);
      color: var(--color-danger);
    }

    .detail-btn.danger:hover {
      background: rgba(248, 81, 73, 0.1);
    }

    /* ===== METRICS GRID ===== */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .metric-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 16px;
    }

    .metric-card.health { border-left: 3px solid var(--color-success); }
    .metric-card.warning { border-left: 3px solid var(--color-warning); }
    .metric-card.critical { border-left: 3px solid var(--color-danger); }

    .metric-label {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .metric-value {
      font-size: 24px;
      font-weight: 600;
    }

    .metric-value.success { color: var(--color-success); }
    .metric-value.warning { color: var(--color-warning); }
    .metric-value.danger { color: var(--color-danger); }

    .metric-detail {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    /* ===== DETAIL CONTENT ===== */
    .detail-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
    }

    .detail-section {
      margin-bottom: 24px;
    }

    .detail-section h3 {
      font-size: 12px;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 12px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    /* ===== CURRENT TASK ===== */
    .task-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
    }

    .task-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }

    .task-title {
      font-size: 16px;
      font-weight: 600;
    }

    .task-meta {
      display: flex;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    .acceptance-list {
      list-style: none;
    }

    .acceptance-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 6px 0;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .acceptance-item.done {
      color: var(--color-success);
    }

    .acceptance-item .check {
      width: 16px;
      height: 16px;
      border: 1px solid var(--border-color);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 10px;
    }

    .acceptance-item.done .check {
      background: var(--color-success);
      border-color: var(--color-success);
      color: white;
    }

    /* ===== TASK QUEUE ===== */
    .queue-list {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .queue-item {
      display: flex;
      align-items: center;
      padding: 10px 16px;
      border-bottom: 1px solid var(--border-color);
      font-size: 13px;
    }

    .queue-item:last-child {
      border-bottom: none;
    }

    .queue-item.next {
      background: rgba(88, 166, 255, 0.1);
    }

    .queue-number {
      width: 24px;
      color: var(--text-muted);
      font-size: 11px;
    }

    .queue-task {
      flex: 1;
    }

    .queue-priority {
      font-size: 10px;
      text-transform: uppercase;
      padding: 2px 6px;
      border-radius: 4px;
      background: var(--bg-hover);
      color: var(--text-muted);
    }

    .queue-priority.critical { background: rgba(248, 81, 73, 0.2); color: var(--color-danger); }
    .queue-priority.high { background: rgba(210, 153, 34, 0.2); color: var(--color-warning); }

    /* ===== CLAIM BADGES ===== */
    .claim-badge {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .claim-badge.claimed {
      background: rgba(88, 166, 255, 0.2);
      color: var(--color-info);
    }

    .claim-badge.claimed-by-me {
      background: rgba(63, 185, 80, 0.2);
      color: var(--color-success);
    }

    .claim-badge.available {
      background: var(--bg-hover);
      color: var(--text-muted);
    }

    .claim-badge.stale {
      background: rgba(210, 153, 34, 0.2);
      color: var(--color-warning);
      animation: pulse 2s infinite;
    }

    .claim-session-id {
      font-size: 8px;
      color: var(--text-muted);
      font-family: monospace;
      max-width: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .queue-item.claimed {
      border-left: 3px solid var(--color-info);
    }

    .queue-item.claimed-by-me {
      border-left: 3px solid var(--color-success);
      background: rgba(63, 185, 80, 0.05);
    }

    .queue-item.stale-claim {
      border-left: 3px solid var(--color-warning);
    }

    .session-task .claim-indicator {
      font-size: 10px;
      margin-left: 4px;
    }

    .session-task .claim-indicator.owned {
      color: var(--color-success);
    }

    .session-task .claim-indicator.stale {
      color: var(--color-warning);
    }

    /* Task queue filters */
    .queue-filters {
      display: flex;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
      flex-wrap: wrap;
    }

    .queue-filter-btn {
      font-size: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      background: var(--bg-hover);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
    }

    .queue-filter-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .queue-filter-btn.active {
      background: var(--color-info);
      border-color: var(--color-info);
      color: white;
    }

    .claim-stats {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
      padding: 4px 0;
    }

    .claim-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .claim-stat-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .claim-stat-dot.claimed { background: var(--color-info); }
    .claim-stat-dot.available { background: var(--color-success); }
    .claim-stat-dot.stale { background: var(--color-warning); }

    /* ===== LOG VIEWER ===== */
    .log-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
    }

    .log-header:hover {
      background: var(--bg-hover);
    }

    .log-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      font-weight: 600;
    }

    .log-streaming-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--color-success);
      animation: pulse 2s infinite;
    }

    .log-controls {
      display: flex;
      gap: 8px;
    }

    .log-content {
      height: 200px;
      overflow-y: auto;
      font-family: 'SF Mono', 'Consolas', monospace;
      font-size: 11px;
      padding: 12px 16px;
      background: var(--bg-primary);
    }

    .log-line {
      padding: 2px 0;
      color: var(--text-secondary);
    }

    .log-line.error { color: var(--color-danger); }
    .log-line.warn { color: var(--color-warning); }
    .log-line.info { color: var(--color-info); }

    /* ===== LESSONS LEARNED ===== */
    .lessons-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .lessons-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
      gap: 12px;
    }

    .lessons-header:hover {
      background: var(--bg-hover);
    }

    .lessons-title {
      font-size: 12px;
      font-weight: 600;
    }

    .lessons-count {
      font-size: 11px;
      color: var(--text-muted);
      background: var(--bg-tertiary);
      padding: 2px 8px;
      border-radius: 10px;
      margin-left: auto;
    }

    .lessons-content {
      max-height: 300px;
      overflow-y: auto;
      padding: 12px 16px;
    }

    .lessons-empty {
      color: var(--text-muted);
      text-align: center;
      padding: 20px;
      font-size: 13px;
    }

    .lesson-item {
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      margin-bottom: 8px;
      border-left: 3px solid var(--color-info);
    }

    .lesson-item:last-child {
      margin-bottom: 0;
    }

    .lesson-item.success { border-left-color: var(--color-success); }
    .lesson-item.warning { border-left-color: var(--color-warning); }
    .lesson-item.error { border-left-color: var(--color-danger); }

    .lesson-task {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
    }

    .lesson-text {
      font-size: 13px;
      color: var(--text-primary);
      line-height: 1.4;
    }

    .lesson-tags {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .lesson-tag {
      font-size: 10px;
      padding: 2px 6px;
      background: var(--bg-hover);
      border-radius: 4px;
      color: var(--text-muted);
    }

    /* ===== USAGE LIMITS DROPDOWN ===== */
    .usage-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      min-width: 320px;
      display: none;
      z-index: 200;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    .usage-dropdown.open {
      display: block;
    }

    .usage-limit {
      margin-bottom: 16px;
    }

    .usage-limit:last-child {
      margin-bottom: 0;
    }

    .usage-limit-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .usage-limit-name {
      font-weight: 600;
    }

    .usage-limit-value {
      color: var(--text-muted);
    }

    .usage-limit-bar {
      height: 6px;
      background: var(--bg-hover);
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 4px;
    }

    .usage-limit-fill {
      height: 100%;
      background: var(--color-success);
      transition: width 0.3s;
    }

    .usage-limit-fill.warning { background: var(--color-warning); }
    .usage-limit-fill.critical { background: var(--color-danger); }

    .usage-limit-meta {
      font-size: 10px;
      color: var(--text-muted);
    }

    /* ===== SETTINGS MODAL ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.open {
      display: flex;
    }

    .modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h2 {
      font-size: 16px;
      font-weight: 600;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 20px;
      padding: 4px;
    }

    .modal-close:hover {
      color: var(--text-primary);
    }

    .modal-body {
      padding: 20px;
      overflow-y: auto;
    }

    .settings-section {
      margin-bottom: 24px;
    }

    .settings-section h3 {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    .settings-option {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid var(--border-muted);
    }

    .settings-option:last-child {
      border-bottom: none;
    }

    .settings-label {
      font-size: 13px;
    }

    .settings-description {
      font-size: 11px;
      color: var(--text-muted);
    }

    .toggle {
      width: 40px;
      height: 22px;
      background: var(--bg-hover);
      border-radius: 11px;
      position: relative;
      cursor: pointer;
      transition: background 0.2s;
    }

    .toggle.active {
      background: var(--color-success);
    }

    .toggle::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: left 0.2s;
    }

    .toggle.active::after {
      left: 20px;
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 900px) {
      .session-list {
        width: 280px;
      }

      /* Compact fleet header for small screens */
      .fleet-header {
        padding: 6px 12px;
        gap: 8px;
        grid-template-columns: 1fr 1fr;
      }

      .fleet-metric-card:last-child {
        display: none;  /* Hide agent pool on small screens */
      }

      .fleet-stats {
        gap: 8px;
      }

      .project-cards {
        grid-template-columns: 1fr;  /* Single column on small screens */
        gap: 8px;
        padding: 8px 12px;
      }
    }

    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }

      .session-list {
        width: 100%;
        height: 40vh;
        border-right: none;
        border-bottom: 1px solid var(--border-color);
      }

      .detail-panel {
        height: 60vh;
      }

      .metrics-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .header-actions {
        gap: 6px;
      }

      .header-btn {
        padding: 4px 8px;
        font-size: 11px;
      }
    }

    /* Mobile (480px and below) */
    @media (max-width: 480px) {
      :root {
        --header-height: 44px;
        --status-bar-height: auto;
      }

      .header h1 {
        font-size: 14px;
      }

      .header-actions {
        gap: 4px;
      }

      .header-btn {
        padding: 4px 6px;
        font-size: 10px;
      }

      .status-bar {
        flex-wrap: wrap;
        padding: 8px 12px;
        gap: 8px;
      }

      .traffic-lights {
        order: 2;
        width: 100%;
        justify-content: center;
      }

      .usage-badge {
        order: 1;
      }

      .status-summary {
        order: 3;
        width: 100%;
        text-align: center;
        margin-left: 0;
      }

      .main-content {
        flex-direction: column;
      }

      .session-list {
        width: 100%;
        height: 35vh;
        min-height: 180px;
      }

      .detail-panel {
        height: 65vh;
      }

      .session-item {
        padding: 10px;
      }

      .session-name {
        font-size: 13px;
      }

      .session-metrics {
        flex-wrap: wrap;
        gap: 8px;
      }

      .session-controls {
        gap: 4px;
      }

      .control-btn {
        padding: 5px;
        font-size: 10px;
      }

      .metrics-grid {
        grid-template-columns: 1fr;
        gap: 8px;
        padding: 12px;
      }

      .metric-card {
        padding: 10px 12px;
      }

      .metric-value {
        font-size: 20px;
      }

      .detail-header {
        flex-direction: column;
        gap: 12px;
        padding: 12px 16px;
      }

      .detail-title {
        font-size: 16px;
      }

      .detail-actions {
        width: 100%;
        display: flex;
        gap: 6px;
      }

      .detail-btn {
        flex: 1;
        padding: 6px 10px;
        font-size: 12px;
        text-align: center;
      }

      .detail-content {
        padding: 12px 16px;
      }

      .task-card {
        padding: 12px;
      }

      .task-title {
        font-size: 14px;
      }

      .phase-progression {
        padding: 6px 8px;
        overflow-x: auto;
      }

      .phase-label {
        font-size: 8px;
      }

      .phase-connector {
        width: 12px;
      }

      .acceptance-item {
        font-size: 12px;
      }

      .log-content {
        height: 150px;
      }

      .modal {
        width: 95%;
        max-height: 85vh;
      }

      .usage-dropdown {
        min-width: 280px;
        right: -50px;
      }
    }

    /* Keyboard focus styles for accessibility */
    .session-item:focus,
    .control-btn:focus,
    .header-btn:focus,
    .detail-btn:focus,
    .toggle:focus,
    .traffic-light:focus {
      outline: 2px solid var(--color-info);
      outline-offset: 2px;
    }

    .session-item:focus-visible,
    .control-btn:focus-visible,
    .header-btn:focus-visible,
    .detail-btn:focus-visible {
      outline: 2px solid var(--color-info);
      outline-offset: 2px;
    }

    /* Skip link for screen readers */
    .skip-link {
      position: absolute;
      top: -40px;
      left: 0;
      background: var(--color-info);
      color: white;
      padding: 8px 16px;
      z-index: 1001;
      text-decoration: none;
      border-radius: 0 0 4px 0;
    }

    .skip-link:focus {
      top: 0;
    }

    /* ===== HIERARCHY VISUALIZATION ===== */
    .hierarchy-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 200px;
    }

    .hierarchy-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
    }

    .hierarchy-panel-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .hierarchy-panel-actions {
      display: flex;
      gap: 6px;
    }

    .hierarchy-panel-actions button {
      padding: 4px 8px;
      font-size: 11px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .hierarchy-panel-actions button:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .hierarchy-panel-body {
      flex: 1;
      overflow: auto;
      padding: 12px;
      max-height: 300px;
    }

    .hierarchy-tree {
      font-size: 12px;
      line-height: 1.5;
    }

    .hierarchy-tree__node {
      position: relative;
      margin: 2px 0;
    }

    .hierarchy-tree__node-row {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s ease;
      background: transparent;
      border: 1px solid transparent;
    }

    .hierarchy-tree__node-row:hover {
      background: var(--bg-hover);
      border-color: var(--border-color);
    }

    .hierarchy-tree__toggle {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
      flex-shrink: 0;
      font-size: 10px;
    }

    .hierarchy-tree__toggle:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .hierarchy-tree__toggle-placeholder {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }

    .hierarchy-tree__status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .hierarchy-tree__status-dot--active {
      background: var(--color-success);
      box-shadow: 0 0 6px var(--color-success);
      animation: pulse 2s ease-in-out infinite;
    }

    .hierarchy-tree__status-dot--completed {
      background: var(--color-success);
    }

    .hierarchy-tree__status-dot--failed {
      background: var(--color-danger);
    }

    .hierarchy-tree__status-dot--pending {
      background: var(--color-warning);
    }

    .hierarchy-tree__status-dot--idle {
      background: var(--text-muted);
    }

    .hierarchy-tree__icon {
      font-size: 12px;
      flex-shrink: 0;
    }

    .hierarchy-tree__name {
      flex: 1;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .hierarchy-tree__badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 16px;
      height: 16px;
      padding: 0 4px;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-secondary);
      background-color: var(--bg-tertiary);
      border-radius: 8px;
    }

    .hierarchy-tree__children {
      margin-left: 16px;
      padding-left: 12px;
      border-left: 1px dashed var(--border-color);
    }

    .hierarchy-tree__node--expanded > .hierarchy-tree__node-row .hierarchy-tree__toggle {
      transform: rotate(90deg);
    }

    .hierarchy-tree__node--selected > .hierarchy-tree__node-row {
      background: rgba(88, 166, 255, 0.1);
      border-color: var(--color-info);
    }

    .hierarchy-tree__node--root > .hierarchy-tree__node-row {
      background: var(--bg-tertiary);
      border-color: var(--border-color);
      padding: 8px 12px;
    }

    .hierarchy-tree__metrics {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-left: auto;
      padding-left: 10px;
    }

    .hierarchy-tree__metric {
      display: flex;
      align-items: center;
      gap: 3px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .hierarchy-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 30px;
      color: var(--text-muted);
      text-align: center;
    }

    .hierarchy-empty-icon {
      font-size: 24px;
      margin-bottom: 8px;
      opacity: 0.5;
    }

    /* ===== DASHBOARD V4 STYLES ===== */

    /* TOP BAR */
    .top-bar {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 6px 12px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .logo {
      font-weight: 700;
      font-size: 12px;
      color: var(--color-info);
    }

    .top-metrics {
      display: flex;
      gap: 16px;
      flex: 1;
    }

    .top-metric {
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .top-metric-label {
      color: var(--text-muted);
      font-size: 10px;
    }

    .top-metric-value {
      font-weight: 600;
    }

    .top-actions {
      display: flex;
      gap: 6px;
    }

    .top-btn {
      padding: 4px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
      font-family: inherit;
      font-size: 10px;
    }

    .top-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    /* ALERT BANNER */
    .alert-banner {
      display: none;
      padding: 6px 12px;
      background: rgba(210, 153, 34, 0.1);
      border-bottom: 1px solid rgba(210, 153, 34, 0.3);
      color: var(--color-warning);
      font-size: 10px;
      align-items: center;
      gap: 8px;
    }

    .alert-banner.visible { display: flex; }

    .alert-dismiss {
      margin-left: auto;
      cursor: pointer;
      opacity: 0.6;
    }

    .alert-dismiss:hover { opacity: 1; }

    /* MAIN LAYOUT - 2 PANEL */
    .main-container {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    .panels {
      display: flex;
      flex: 1;
      overflow: hidden;
      min-height: 200px; /* Debug: ensure minimum height */
    }

    /* LEFT PANEL: SESSIONS */
    .left-panel {
      width: 260px;
      min-width: 200px;
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--bg-secondary);
    }

    .panel-header {
      padding: 8px 10px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
      font-size: 10px;
      text-transform: uppercase;
      color: var(--text-secondary);
      display: flex;
      justify-content: space-between;
    }

    .session-list {
      flex: 1;
      overflow-y: auto;
    }

    .session-group {
      border-bottom: 1px solid var(--border-color);
    }

    .session-group-header {
      padding: 6px 10px;
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 10px;
      font-weight: 600;
    }

    .session-group-header:hover {
      background: var(--bg-hover);
    }

    .session-group-toggle {
      color: var(--text-muted);
      font-size: 8px;
      transition: transform 0.15s;
    }

    .session-group.collapsed .session-group-toggle {
      transform: rotate(-90deg);
    }

    .session-group.collapsed .session-group-items {
      display: none;
    }

    .session-group-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .session-group-count {
      color: var(--text-muted);
      font-size: 9px;
    }

    /* Session item */
    .session-item {
      padding: 8px 10px 8px 18px;
      border-bottom: 1px solid var(--border-muted);
      cursor: pointer;
    }

    .session-item:hover {
      background: var(--bg-tertiary);
    }

    .session-item.selected {
      background: var(--bg-hover);
      border-left: 2px solid var(--color-info);
      padding-left: 16px;
    }

    .session-row-1 {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 3px;
    }

    .session-status {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .session-status.active { background: var(--color-success); }
    .session-status.idle { background: var(--text-muted); }
    .session-status.warning { background: var(--color-warning); }

    .session-name {
      flex: 1;
      font-size: 11px;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Session type badge */
    .session-type {
      font-size: 8px;
      padding: 1px 4px;
      border-radius: 2px;
      font-weight: 600;
    }

    .session-type.cli {
      background: rgba(88, 166, 255, 0.15);
      color: var(--color-info);
    }

    .session-type.auto {
      background: rgba(163, 113, 247, 0.15);
      color: var(--color-purple);
    }

    .session-row-2 {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 9px;
      color: var(--text-muted);
    }

    .session-phase {
      color: var(--text-secondary);
    }

    .session-ctx {
      margin-left: auto;
    }

    .session-ctx.warn { color: var(--color-warning); }
    .session-ctx.crit { color: var(--color-danger); }

    .prediction-chip {
      font-size: 8px;
      padding: 1px 4px;
      border-radius: 2px;
      background: rgba(88, 166, 255, 0.15);
      color: var(--color-info);
    }

    .prediction-chip.warn {
      background: rgba(210, 153, 34, 0.15);
      color: var(--color-warning);
    }

    .prediction-chip.crit {
      background: rgba(248, 81, 73, 0.15);
      color: var(--color-danger);
    }

    /* RIGHT PANEL: CONTENT */
    .right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-width: 0;
    }

    .view-tabs {
      display: flex;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      overflow-x: auto;
    }

    .view-tab {
      padding: 8px 12px;
      color: var(--text-secondary);
      cursor: pointer;
      border-bottom: 2px solid transparent;
      font-size: 10px;
      white-space: nowrap;
    }

    .view-tab:hover {
      color: var(--text-primary);
      background: var(--bg-tertiary);
    }

    .view-tab.active {
      color: var(--color-info);
      border-bottom-color: var(--color-info);
    }

    .view-content {
      flex: 1;
      overflow: auto;
      padding: 12px;
    }

    .view-pane { display: none; }
    .view-pane.active { display: block; }

    /* METRICS GRID */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      margin-bottom: 16px;
    }

    .metric-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 10px;
    }

    .metric-card-label {
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .metric-card-value {
      font-size: 18px;
      font-weight: 600;
    }

    .metric-card-bar {
      height: 4px;
      background: var(--bg-tertiary);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 6px;
    }

    .metric-card-bar-fill {
      height: 100%;
      border-radius: 2px;
    }

    /* PREDICTION SECTION */
    .prediction-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 12px;
      margin-bottom: 16px;
    }

    .prediction-header {
      font-size: 10px;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .prediction-items {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .prediction-item {
      flex: 1;
      min-width: 120px;
      padding: 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    .prediction-label {
      font-size: 9px;
      color: var(--text-muted);
      margin-bottom: 2px;
      display: block;
    }

    .prediction-value {
      font-size: 14px;
      font-weight: 600;
      display: block;
    }

    /* DATA TABLE */
    .section-header {
      font-size: 10px;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px solid var(--border-color);
      margin-top: 16px;
    }

    .section-header:first-child {
      margin-top: 0;
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .data-table th {
      text-align: left;
      padding: 6px 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      color: var(--text-muted);
      font-size: 9px;
      text-transform: uppercase;
    }

    .data-table td {
      padding: 6px 8px;
      border: 1px solid var(--border-color);
    }

    .data-table tr:hover td {
      background: var(--bg-tertiary);
    }

    .status-badge {
      display: inline-block;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .status-badge.completed { background: rgba(63, 185, 80, 0.15); color: var(--color-success); }
    .status-badge.in-progress { background: rgba(88, 166, 255, 0.15); color: var(--color-info); }
    .status-badge.blocked { background: rgba(248, 81, 73, 0.15); color: var(--color-danger); }
    .status-badge.ready { background: rgba(139, 148, 158, 0.15); color: var(--text-secondary); }

    /* Score bar inline */
    .score-bar-inline {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .score-bar-track {
      width: 40px;
      height: 6px;
      background: var(--bg-tertiary);
      border-radius: 3px;
      overflow: hidden;
    }

    .score-bar-fill {
      height: 100%;
      border-radius: 3px;
    }

    /* HIERARCHY TAB */
    .hierarchy-tree {
      font-size: 11px;
    }

    .hierarchy-node {
      padding: 2px 0;
    }

    .hierarchy-row {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
    }

    .hierarchy-row:hover {
      background: var(--bg-tertiary);
    }

    .hierarchy-children {
      margin-left: 18px;
      border-left: 1px dashed var(--border-color);
      padding-left: 8px;
    }

    /* KEYBOARD BAR */
    .keyboard-bar {
      padding: 6px 12px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border-color);
      font-size: 9px;
      color: var(--text-muted);
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    kbd {
      display: inline-block;
      padding: 1px 4px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 2px;
      font-family: inherit;
      font-size: 9px;
      margin-right: 3px;
    }

    /* RESPONSIVE */
    @media (max-width: 600px) {
      .left-panel { width: 180px; min-width: 150px; }
      .top-metrics { gap: 10px; font-size: 9px; }
      .metrics-grid { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <!-- Skip link for keyboard/screen reader users -->
  <a href="#sessionItems" class="skip-link" tabindex="1">Skip to session list</a>

  <div class="app-container">
    <!-- TOP BAR (v4) -->
    <div class="top-bar">
      <span class="logo">FLEET</span>
      <div class="top-metrics">
        <div class="top-metric">
          <span class="top-metric-label">PROJECTS</span>
          <span class="top-metric-value" id="metricProjects">0</span>
        </div>
        <div class="top-metric">
          <span class="top-metric-label">SESSIONS</span>
          <span class="top-metric-value" id="metricSessions">0</span>
        </div>
        <div class="top-metric">
          <span class="top-metric-label">TASKS</span>
          <span class="top-metric-value" id="metricTasks">0/0</span>
        </div>
        <div class="top-metric">
          <span class="top-metric-label">AGENTS</span>
          <span class="top-metric-value" id="metricAgents">0</span>
          <span class="top-metric-label" id="metricSubAgents">/ 0 sub</span>
        </div>
      </div>
      <div class="top-actions">
        <button class="top-btn header-btn-new" onclick="openNewSessionModal()">+ Session</button>
        <button class="top-btn" onclick="toggleSettings()"></button>
      </div>
    </div>


    <!-- Alert Banner (v4) -->
    <div class="alert-banner" id="alertBanner" role="alert">
      <span></span>
      <span id="alertMessage"></span>
      <span class="alert-dismiss" onclick="dismissAlertBanner()"></span>
    </div>

    <!-- MAIN CONTAINER (v4 2-panel layout) -->
    <div class="main-container">
      <div class="panels">
        <!-- LEFT PANEL: SESSIONS -->
        <div class="left-panel">
          <div class="panel-header">
            <span>Sessions</span>
            <span id="sessionCount">0</span>
          </div>
          <div class="session-list" id="sessionList">
            <div style="padding: 10px; color: #58a6ff;">Loading sessions...</div>
          </div>
          <!-- Backward compatibility for v3 tests -->
          <div id="projectCards" style="display:none"></div>
        </div>

        <!-- RIGHT PANEL: CONTENT -->
        <div class="right-panel">
          <div class="view-tabs">
            <div class="view-tab active" data-tab="overview" onclick="switchTab('overview')">Overview</div>
            <div class="view-tab" data-tab="tasks" onclick="switchTab('tasks')">Tasks</div>
            <div class="view-tab" data-tab="hierarchy" onclick="switchTab('hierarchy')">Hierarchy</div>
            <div class="view-tab" data-tab="details" onclick="switchTab('details')">Details</div>
            <div class="view-tab" data-tab="logs" onclick="switchTab('logs')">Logs</div>
          </div>
          <div class="view-content">
            <div class="view-pane active" id="pane-overview">
              <div class="section-header">Select a session</div>
              <p style="color: var(--text-muted)">Click a session in the left panel to view details.</p>
            </div>
            <div class="view-pane" id="pane-tasks">
              <!-- Tasks tab content - Phase 3 -->
            </div>
            <div class="view-pane" id="pane-hierarchy">
              <!-- Hierarchy tab content -->
              <div id="fleetLineageSection">
                <div id="fleetHierarchyContainer"></div>
              </div>
            </div>
            <div class="view-pane" id="pane-details">
              <!-- Details tab content - Phase 3 -->
            </div>
            <div class="view-pane" id="pane-logs">
              <!-- Logs tab content - Phase 3 -->
            </div>
          </div>
        </div>
      </div>

      <!-- KEYBOARD BAR -->
      <div class="keyboard-bar">
        <span><kbd>j</kbd><kbd>k</kbd> navigate</span>
        <span><kbd>1</kbd>-<kbd>5</kbd> tabs</span>
        <span><kbd>n</kbd> new session</span>
        <span><kbd>?</kbd> help</span>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
    <div class="modal">
      <div class="modal-header">
        <h2 id="settingsTitle">Settings</h2>
        <button class="modal-close" onclick="toggleSettings()" aria-label="Close settings" tabindex="0">&times;</button>
      </div>
      <div class="modal-body">
        <div class="settings-section">
          <h3>Health & Stability Metrics</h3>
          <div class="settings-option">
            <div>
              <div class="settings-label">Error Count</div>
              <div class="settings-description">Show task retry attempts and failures</div>
            </div>
            <div class="toggle active" data-setting="showErrorCount" onclick="toggleSetting(this)"></div>
          </div>
          <div class="settings-option">
            <div>
              <div class="settings-label">Quality Trend</div>
              <div class="settings-description">Show quality score direction (improving/declining)</div>
            </div>
            <div class="toggle active" data-setting="showQualityTrend" onclick="toggleSetting(this)"></div>
          </div>
          <div class="settings-option">
            <div>
              <div class="settings-label">Blocking Issues</div>
              <div class="settings-description">Highlight tasks that block other work</div>
            </div>
            <div class="toggle active" data-setting="showBlockingIssues" onclick="toggleSetting(this)"></div>
          </div>
        </div>

        <div class="settings-section">
          <h3>Progress & Velocity Metrics</h3>
          <div class="settings-option">
            <div>
              <div class="settings-label">Token Burn Rate</div>
              <div class="settings-description">Show tokens consumed per hour</div>
            </div>
            <div class="toggle active" data-setting="showTokenBurnRate" onclick="toggleSetting(this)"></div>
          </div>
          <div class="settings-option">
            <div>
              <div class="settings-label">Context Exhaustion ETA</div>
              <div class="settings-description">Predicted time until context limit</div>
            </div>
            <div class="toggle active" data-setting="showExhaustionETA" onclick="toggleSetting(this)"></div>
          </div>
          <div class="settings-option">
            <div>
              <div class="settings-label">Acceptance Progress</div>
              <div class="settings-description">Show criteria completion percentage</div>
            </div>
            <div class="toggle active" data-setting="showAcceptanceProgress" onclick="toggleSetting(this)"></div>
          </div>
        </div>

        <div class="settings-section">
          <h3>Resource & Cost Metrics</h3>
          <div class="settings-option">
            <div>
              <div class="settings-label">Cost Display</div>
              <div class="settings-description">Show session and total costs</div>
            </div>
            <div class="toggle" data-setting="showCost" onclick="toggleSetting(this)"></div>
          </div>
          <div class="settings-option">
            <div>
              <div class="settings-label">Model Usage</div>
              <div class="settings-description">Show which AI model is being used</div>
            </div>
            <div class="toggle" data-setting="showModel" onclick="toggleSetting(this)"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Session Launcher Modal -->
  <div class="modal-overlay" id="sessionLauncherModal">
    <div class="modal">
      <div class="modal-header">
        <h2>Launch New Session</h2>
        <button class="modal-close" onclick="closeNewSessionModal()">&times;</button>
      </div>
      <div class="modal-body">
        <p style="color: var(--text-muted); margin-bottom: 12px;">Select a project or enter a custom path:</p>
        <div id="projectList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; margin-bottom: 12px;">
          <div style="padding: 20px; text-align: center; color: var(--text-muted);">Loading...</div>
        </div>
        <div style="margin-top: 12px;">
          <label style="display: block; margin-bottom: 6px; color: var(--text-secondary);">Custom Path:</label>
          <input type="text" id="customProjectPath" placeholder="C:\path\to\project" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-tertiary); color: var(--text-primary); font-family: monospace;">
        </div>
      </div>
      <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color);">
        <button onclick="closeNewSessionModal()" style="padding: 8px 16px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); cursor: pointer;">Cancel</button>
        <button onclick="launchSession()" style="padding: 8px 16px; background: var(--color-info); border: none; border-radius: 4px; color: white; cursor: pointer;">Launch</button>
      </div>
    </div>
  </div>

  <script>
    // ===== STATE =====
    let sessions = [];
    let selectedSessionId = null;
    let predictions = {};
    let usageLimits = {};
    let eventSource = null;
    // Per-project task/execution data (key = project path)
    const projectDataMap = new Map();
    // Legacy single-project references (for backward compatibility)
    let tasksData = { tasks: [], stats: {} };
    let executionState = {};
    // Claims data for task ownership tracking
    let claimsData = {
      claims: [],           // All active claims from /api/tasks/in-flight
      stats: {},            // Claim statistics
      lastFetched: null     // Timestamp of last fetch
    };
    // Queue filter state
    let queueFilter = 'all'; // 'all', 'claimed', 'available', 'mine'

    // Short session ID mapping (longId -> shortId like "S1", "S2", etc.)
    const shortIdMap = new Map();
    let shortIdCounter = 1;

    // Settings (persisted to localStorage)
    let settings = {
      showErrorCount: true,
      showQualityTrend: true,
      showBlockingIssues: true,
      showTokenBurnRate: true,
      showExhaustionETA: true,
      showAcceptanceProgress: true,
      showCost: false,
      showModel: false
    };

    // Load settings from localStorage
    const savedSettings = localStorage.getItem('dashboardSettings');
    if (savedSettings) {
      settings = { ...settings, ...JSON.parse(savedSettings) };
    }

    // Phase progression configuration
    const PHASES = ['research', 'design', 'implement', 'test'];

    // Render phase progression indicator for a task
    function renderPhaseProgression(taskId, currentPhase) {
      const taskPhases = executionState.taskPhaseHistory?.[taskId] || {
        phases: [],
        currentPhase: currentPhase,
        scores: {}
      };

      const completedPhases = taskPhases.phases || [];
      const activePhase = taskPhases.currentPhase || currentPhase;

      return `
        <div class="phase-progression">
          ${PHASES.map((phase, idx) => {
            const isCompleted = completedPhases.includes(phase);
            const isCurrent = phase === activePhase && !isCompleted;
            const isPending = !isCompleted && !isCurrent;
            const score = taskPhases.scores?.[phase];

            const statusClass = isCompleted ? 'completed' : (isCurrent ? 'current' : 'pending');
            const icon = isCompleted ? '' : (isCurrent ? '' : (idx + 1));

            const connector = idx < PHASES.length - 1 ? `
              <div class="phase-connector ${isCompleted ? 'completed' : ''}"></div>
            ` : '';

            return `
              <div class="phase-step">
                <div style="display: flex; flex-direction: column; align-items: center;">
                  <div class="phase-dot ${statusClass}">${icon}</div>
                  <span class="phase-label ${statusClass}">${phase}</span>
                  ${score ? `<span class="phase-score">${score}</span>` : ''}
                </div>
              </div>
              ${connector}
            `;
          }).join('')}
        </div>
      `;
    }

    // ===== INITIALIZATION =====
    async function init() {
      loadSettingsUI();

      // Fetch sessions first, then enrich with task/execution data
      await fetchSessions();
      await fetchTasksAndExecution(); // Enrich immediately after

      // Then fetch other data in parallel (including claims)
      await Promise.all([
        fetchUsageLimits(),
        fetchPredictions(),
        fetchInFlightTasks()
      ]);

      // Now connect SSE (which will preserve enriched data)
      connectSSE();

      // Initialize Fleet Management (NEW)
      await initFleetManagement();

      // Refresh usage limits every minute
      setInterval(fetchUsageLimits, 60000);
      // Refresh tasks every 10 seconds (reduced frequency to prevent flicker)
      setInterval(fetchTasksAndExecution, 10000);
      // Refresh claims every 15 seconds
      setInterval(fetchInFlightTasks, 15000);
    }

    async function fetchTasksAndExecution() {
      try {
        // Get unique project paths from all sessions
        const uniqueProjectPaths = new Set();
        for (const session of sessions) {
          if (session.path) {
            uniqueProjectPaths.add(session.path);
          }
        }

        // If no sessions with paths, fetch default project data
        if (uniqueProjectPaths.size === 0) {
          const [tasksRes, execRes] = await Promise.all([
            fetch('/api/tasks'),
            fetch('/api/execution')
          ]);
          tasksData = await tasksRes.json();
          executionState = await execRes.json();
          enrichActiveSession();
          return;
        }

        // Fetch tasks and execution state for EACH unique project
        const fetchPromises = [];
        const projectPaths = Array.from(uniqueProjectPaths);

        for (const projectPath of projectPaths) {
          const encodedPath = encodeURIComponent(projectPath);
          fetchPromises.push(
            Promise.all([
              fetch(`/api/tasks?projectPath=${encodedPath}`),
              fetch(`/api/execution?projectPath=${encodedPath}`)
            ]).then(async ([tasksRes, execRes]) => ({
              projectPath,
              tasks: await tasksRes.json(),
              execution: await execRes.json()
            }))
          );
        }

        // Wait for all fetches to complete
        const results = await Promise.all(fetchPromises);
        let anyChanged = false;

        // Store results in the projectDataMap
        for (const result of results) {
          const oldData = projectDataMap.get(result.projectPath);
          const newData = {
            tasks: result.tasks,
            execution: result.execution
          };

          // Check if data changed for this project
          const tasksChanged = !oldData || JSON.stringify(oldData.tasks?.stats) !== JSON.stringify(newData.tasks?.stats);
          const execChanged = !oldData || JSON.stringify(oldData.execution?.qualityScores) !== JSON.stringify(newData.execution?.qualityScores);

          if (tasksChanged || execChanged) {
            anyChanged = true;
          }

          projectDataMap.set(result.projectPath, newData);
        }

        // Update legacy references with first project's data (for backward compatibility)
        if (results.length > 0) {
          tasksData = results[0].tasks;
          executionState = results[0].execution;
        }

        // Enrich sessions with their project's data
        enrichActiveSession();

        // Only update UI if data changed
        if (anyChanged) {
          updateTrafficLights();
          updateSessionList();
          if (selectedSessionId) {
            updateDetailPanel();
          }
        }
      } catch (err) {
        console.error('Failed to fetch tasks/execution:', err);
      }
    }

    function enrichActiveSession() {
      // Group sessions by project path for per-project enrichment
      const sessionsByPath = new Map();

      for (const session of sessions) {
        const projectPath = session.path;
        if (!projectPath) continue;

        if (!sessionsByPath.has(projectPath)) {
          sessionsByPath.set(projectPath, []);
        }
        sessionsByPath.get(projectPath).push(session);
      }

      // Enrich each project's sessions with that project's data
      for (const [projectPath, projectSessions] of sessionsByPath) {
        // Get this project's data from the map
        const projectData = projectDataMap.get(projectPath) || {
          tasks: { tasks: [], stats: {} },
          execution: {}
        };

        const projectTasksData = projectData.tasks || { tasks: [], stats: {} };
        const projectExecutionState = projectData.execution || {};

        // Build task data for this project
        let taskQueue = [];
        let currentTask = null;

        if (projectTasksData.tasks && projectTasksData.tasks.length > 0) {
          taskQueue = projectTasksData.tasks
            .filter(t => t.status === 'ready')
            .sort((a, b) => {
              const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
              return (priorityOrder[a.priority] || 2) - (priorityOrder[b.priority] || 2);
            })
            .slice(0, 10);

          const inProgressTask = projectTasksData.tasks.find(t => t.status === 'in_progress');
          if (inProgressTask) {
            currentTask = {
              id: inProgressTask.id,
              title: inProgressTask.title,
              description: inProgressTask.description,
              phase: inProgressTask.phase || projectExecutionState.currentPhase,
              priority: inProgressTask.priority,
              estimate: inProgressTask.estimate,
              acceptance: (inProgressTask.acceptance || []).map(a =>
                typeof a === 'string' ? { text: a, done: false } : a
              ),
              attempts: inProgressTask.attempts || 1
            };
          } else if (taskQueue.length > 0) {
            const nextTask = taskQueue[0];
            currentTask = {
              id: nextTask.id,
              title: nextTask.title,
              description: nextTask.description,
              phase: nextTask.phase || projectExecutionState.currentPhase,
              priority: nextTask.priority,
              estimate: nextTask.estimate,
              acceptance: (nextTask.acceptance || []).map(a =>
                typeof a === 'string' ? { text: a, done: false } : a
              ),
              attempts: 1
            };
          }
        }

        // Apply this project's data to its sessions
        for (const session of projectSessions) {
          // Only set phase if session doesn't have its own
          if (projectExecutionState.currentPhase && !session.phase) {
            session.phase = projectExecutionState.currentPhase;
            session.iteration = projectExecutionState.phaseIteration || 1;
          }
          // DON'T overwrite session-specific quality scores
          // Each session tracks its own quality from the session registry

          // Task queue is project-level, safe to share for available tasks view
          session.taskQueue = taskQueue;
          session.taskStats = projectTasksData.stats || {};

          // IMPORTANT: Use session's claimed task if available, otherwise fall back to project-level
          // This ensures each session shows its own work, not a shared view
          if (session.claimInfo && session.claimedTaskId) {
            // Session has a claimed task - look it up from project tasks
            const claimedTask = projectTasksData.tasks?.find(t => t.id === session.claimedTaskId);
            if (claimedTask) {
              session.currentTask = {
                id: claimedTask.id,
                title: claimedTask.title,
                description: claimedTask.description,
                phase: claimedTask.phase || session.phase,
                priority: claimedTask.priority,
                estimate: claimedTask.estimate,
                acceptance: (claimedTask.acceptance || []).map(a =>
                  typeof a === 'string' ? { text: a, done: false } : a
                ),
                attempts: claimedTask.attempts || 1,
                claimed: true,  // Mark as claimed
                claimInfo: session.claimInfo
              };
            }
          } else if (session.currentTask) {
            // Session already has currentTask from API (autonomous sessions)
            // Keep it as-is, don't overwrite
          } else {
            // No claim and no existing task - use project-level current task
            session.currentTask = currentTask;
          }
        }
      }
    }

    // ===== DATA FETCHING =====
    async function fetchSessions() {
      console.log('[Dashboard] fetchSessions starting...');
      try {
        // Fetch both projects (CLI sessions) and sessions/summary (autonomous orchestrator sessions)
        const [projectsRes, summaryRes] = await Promise.all([
          fetch('/api/projects'),
          fetch('/api/sessions/summary')
        ]);
        const projectsData = await projectsRes.json();
        const summaryData = await summaryRes.json();
        console.log('[Dashboard] fetchSessions got projects:', projectsData?.projects?.length, 'summaries:', summaryData?.sessions?.length);

        // Build list of ALL sessions - never merge CLI and autonomous
        const allSessions = [];

        // 1. Add all CLI sessions from projects (each as separate entry)
        for (const p of (projectsData.projects || [])) {
          // Filter out agent-* sessions (subagent tasks) and 'default' placeholder
          // 'default' is a legacy placeholder that shouldn't appear when real sessions exist
          const hasRealSessions = (p.sessions || []).some(s => s.id && s.id !== 'default' && !s.id.startsWith('agent-'));
          const cliSessions = (p.sessions || []).filter(s => {
            const id = s.id || '';
            // Skip agent sessions
            if (id.startsWith('agent-') || id.includes('/agent-')) return false;
            // Skip 'default' placeholder if real sessions exist
            if (id === 'default' && hasRealSessions) return false;
            return true;
          });

          // Always show each CLI session separately
          for (const cliSession of cliSessions) {
            // Double-check: skip if this is an agent session
            if (cliSession.id?.startsWith('agent-')) continue;

            const sessionId = `cli-${p.folder}-${cliSession.id}`;
            const existingSession = sessions.find(s => s.id === sessionId);

            // Consider session active if:
            // 1. Session is explicitly marked active, OR
            // 2. Has activity within the last 5 minutes
            const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
            const lastUpdateTime = typeof cliSession.lastUpdate === 'number' ? cliSession.lastUpdate : 0;
            const hasRecentActivity = lastUpdateTime > fiveMinutesAgo;
            const isActive = cliSession.isActive || hasRecentActivity;

            // Only show active sessions (skip old/inactive ones)
            if (!isActive) continue;

            allSessions.push({
              id: sessionId,
              project: p.name,
              path: p.path,
              folder: p.folder,
              cliSessionId: cliSession.id,
              sessionType: 'cli',
              status: isActive ? 'active' : 'idle',
              // Use per-session context (fallback to project for backward compat)
              contextPercent: cliSession.contextPercent ?? p.metrics?.contextPercent ?? 0,
              contextUsed: cliSession.contextUsed ?? p.metrics?.contextUsed ?? 0,
              qualityScore: existingSession?.qualityScore || 0,
              qualityBreakdown: existingSession?.qualityBreakdown || {},
              // Use per-session cost (fallback to project for backward compat)
              cost: cliSession.cost ?? p.metrics?.cost ?? 0,
              // Use contextUsed (includes cache tokens) to match statusline display
              tokens: cliSession.contextUsed ?? ((cliSession.inputTokens || 0) + (cliSession.outputTokens || 0) + (cliSession.cacheReadTokens || 0) + (cliSession.cacheCreationTokens || 0)),
              // Include individual token counts and messages for Overview pane
              inputTokens: cliSession.inputTokens || 0,
              outputTokens: cliSession.outputTokens || 0,
              messages: cliSession.messageCount || 0,
              // Use per-session model (fallback to project for backward compat)
              model: cliSession.model ?? p.metrics?.model,
              messageCount: cliSession.messageCount || 0,
              currentTask: existingSession?.currentTask || null,
              taskQueue: existingSession?.taskQueue || [],
              taskStats: existingSession?.taskStats || {},
              phase: existingSession?.phase || null,
              autonomous: false,
              iteration: existingSession?.iteration || 1,
              safetyStatus: isActive ? p.safetyStatus : 'OK',
              logSessionId: null,
              orchestratorInfo: null,
              confidenceScore: null,
              registryId: null,
              lastUpdate: cliSession.lastUpdate,
              startTime: cliSession.lastUpdate, // For display
              // Phase 4: Claim-based current task (CLI sessions look up from claimsData)
              claimedTaskId: existingSession?.claimedTaskId || null,
              claimInfo: existingSession?.claimInfo || null
            });
          }

          // If no CLI sessions but project exists, still show it
          if (cliSessions.length === 0) {
            allSessions.push({
              id: `cli-${p.folder}-default`,
              project: p.name,
              path: p.path,
              folder: p.folder,
              cliSessionId: 'default',
              sessionType: 'cli',
              status: p.status === 'active' ? 'active' : 'idle',
              contextPercent: p.metrics?.contextPercent || 0,
              qualityScore: 0,
              qualityBreakdown: {},
              cost: p.metrics?.cost || 0,
              tokens: p.metrics?.contextUsed || 0,
              model: p.metrics?.model,
              messageCount: p.metrics?.messageCount || 0,
              currentTask: null,
              taskQueue: [],
              taskStats: {},
              phase: null,
              autonomous: false,
              iteration: 1,
              safetyStatus: p.safetyStatus,
              logSessionId: null,
              orchestratorInfo: null,
              confidenceScore: null,
              registryId: null,
              lastUpdate: p.metrics?.lastUpdate,
              startTime: p.metrics?.lastUpdate,
              // Phase 4: No claims for default placeholder sessions
              claimedTaskId: null,
              claimInfo: null
            });
          }
        }

        // 2. Add all autonomous sessions as separate entries (never merge)
        for (const s of (summaryData.sessions || [])) {
          if (s.status === 'ended') continue; // Skip ended sessions by default

          const projectName = s.project || s.path?.split(/[\\/]/).pop() || 'Unknown Project';
          const folder = s.path ? s.path.replace(/:/g, '').replace(/[\\/]/g, '-') : null;

          allSessions.push({
            id: `auto-${s.id}`,
            project: projectName,
            path: s.path,
            folder: folder,
            cliSessionId: null,
            sessionType: 'autonomous',
            status: s.status || 'active',
            contextPercent: s.contextPercent || 0,
            qualityScore: s.qualityScore || 0,
            qualityBreakdown: {},
            cost: s.cost || 0,
            tokens: s.tokens || 0,
            // Include individual token counts and messages for Overview pane
            inputTokens: s.inputTokens || 0,
            outputTokens: s.outputTokens || 0,
            messages: s.messages || 0,
            model: null,
            messageCount: s.messages || 0,
            currentTask: s.currentTask || null,
            taskQueue: s.taskQueue || [],
            taskStats: {},
            phase: s.phase || null,
            autonomous: true,
            iteration: s.iteration || 1,
            safetyStatus: null,
            logSessionId: s.logSessionId || null,
            orchestratorInfo: s.orchestratorInfo || null,
            confidenceScore: s.confidenceScore || null,
            registryId: s.id,
            lastUpdate: s.lastUpdate || s.startTime,
            startTime: s.startTime,
            // Phase 4: Claim-based current task from /api/sessions/summary
            claimedTaskId: s.currentTaskId || null,
            claimInfo: s.claimInfo || null
          });
        }

        // Sort by: active first, then by lastUpdate (most recent first)
        allSessions.sort((a, b) => {
          // Active sessions first
          const aActive = a.status === 'active' ? 1 : 0;
          const bActive = b.status === 'active' ? 1 : 0;
          if (aActive !== bActive) return bActive - aActive;
          // Then by most recent activity
          return (b.lastUpdate || 0) - (a.lastUpdate || 0);
        });

        // Final filter: remove any sessions with agent IDs that slipped through
        sessions = allSessions.filter(s => {
          const cliId = s.cliSessionId || '';
          return !cliId.startsWith('agent-');
        });

        // Clean up short IDs for sessions that no longer exist
        cleanupShortIds(sessions.map(s => s.id));

        // Note: Enrichment with task/execution data happens in fetchTasksAndExecution()
        updateTrafficLights();
        updateSessionList();
      } catch (err) {
        console.error('Failed to fetch sessions:', err);
      }
    }

    async function fetchUsageLimits() {
      try {
        const res = await fetch('/api/usage/limits');
        usageLimits = await res.json();
        updateUsageDisplay();
      } catch (err) {
        console.error('Failed to fetch usage limits:', err);
      }
    }

    async function fetchPredictions() {
      try {
        const res = await fetch('/api/predictions');
        predictions = await res.json();
      } catch (err) {
        console.error('Failed to fetch predictions:', err);
      }
    }

    // Fetch all active task claims (in-flight tasks)
    async function fetchInFlightTasks() {
      try {
        const [claimsRes, statsRes] = await Promise.all([
          fetch('/api/tasks/in-flight'),
          fetch('/api/tasks/claims/stats')
        ]);

        if (claimsRes.ok) {
          const data = await claimsRes.json();
          claimsData.claims = data.claims || [];
          claimsData.lastFetched = Date.now();
        }

        if (statsRes.ok) {
          claimsData.stats = await statsRes.json();
        }
      } catch (err) {
        console.error('Failed to fetch in-flight tasks:', err);
      }
    }

    // Get claim info for a specific task
    function getClaimForTask(taskId) {
      return claimsData.claims.find(c => c.taskId === taskId);
    }

    // Check if a claim is stale (last heartbeat > 2 minutes ago)
    function isClaimStale(claim) {
      if (!claim || !claim.lastHeartbeat) return false;
      const twoMinutesAgo = Date.now() - (2 * 60 * 1000);
      const heartbeatTime = new Date(claim.lastHeartbeat).getTime();
      return heartbeatTime < twoMinutesAgo;
    }

    // Get claim status for a task (used for UI display)
    function getClaimStatus(taskId, currentSessionId) {
      const claim = getClaimForTask(taskId);
      if (!claim) return { status: 'available', claim: null };

      const isStale = isClaimStale(claim);
      const isMine = claim.sessionId === currentSessionId;

      if (isStale) return { status: 'stale', claim };
      if (isMine) return { status: 'mine', claim };
      return { status: 'claimed', claim };
    }

    // Get or assign a short session ID (S1, S2, S3...)
    function getShortSessionId(longId) {
      if (!longId) return '';
      if (shortIdMap.has(longId)) {
        return shortIdMap.get(longId);
      }
      const shortId = `S${shortIdCounter++}`;
      shortIdMap.set(longId, shortId);
      return shortId;
    }

    // Clean up short IDs for sessions that no longer exist
    function cleanupShortIds(currentSessionIds) {
      const currentSet = new Set(currentSessionIds);
      for (const [longId] of shortIdMap) {
        if (!currentSet.has(longId)) {
          shortIdMap.delete(longId);
        }
      }
    }

    // Format session ID for display (short version)
    function formatClaimSessionId(sessionId) {
      if (!sessionId) return '';
      // If it's a UUID, show last 8 chars
      if (sessionId.length > 12) {
        return sessionId.slice(-8);
      }
      return sessionId;
    }

    // Render claim badge for task queue
    function renderClaimBadge(claimStatus) {
      if (claimStatus.status === 'available') {
        return '<span class="claim-badge available">Available</span>';
      }
      if (claimStatus.status === 'mine') {
        return '<span class="claim-badge claimed-by-me">Mine</span>';
      }
      if (claimStatus.status === 'stale') {
        const shortId = formatClaimSessionId(claimStatus.claim?.sessionId);
        return `<span class="claim-badge stale" title="Claim may be stale - session ${shortId}"> Stale</span>`;
      }
      // claimed by another session
      const shortId = formatClaimSessionId(claimStatus.claim?.sessionId);
      return `<span class="claim-badge claimed" title="Claimed by session ${shortId}">Claimed</span>`;
    }

    // Set queue filter and refresh
    function setQueueFilter(filter) {
      queueFilter = filter;
      if (selectedSessionId) {
        updateDetailPanel(sessions.find(s => s.id === selectedSessionId));
      }
    }

    // Handle claim events from SSE
    function handleClaimEvent(event) {
      const { type, taskId, sessionId, claim } = event;

      switch (type) {
        case 'task:claimed':
          // Add or update claim in local cache
          const existingIdx = claimsData.claims.findIndex(c => c.taskId === taskId);
          if (existingIdx >= 0) {
            claimsData.claims[existingIdx] = claim;
          } else {
            claimsData.claims.push(claim);
          }
          // Update session's claimed task if this is for a session we're tracking
          updateSessionClaimedTask(sessionId, taskId, claim);
          break;

        case 'task:released':
        case 'task:claim-expired':
        case 'task:claim-orphaned':
          // Remove claim from local cache
          claimsData.claims = claimsData.claims.filter(c => c.taskId !== taskId);
          // Clear session's claimed task
          clearSessionClaimedTask(sessionId, taskId);
          break;

        case 'task:claims-cleaned':
          // Multiple claims were cleaned - refetch all claims
          fetchInFlightTasks();
          break;
      }

      // Update UI
      updateSessionList();
      if (selectedSessionId) {
        updateDetailPanel(sessions.find(s => s.id === selectedSessionId));
      }
    }

    // Update a session's claimed task when claim event received
    function updateSessionClaimedTask(sessionId, taskId, claim) {
      // Find session by registryId (for autonomous) or construct CLI session ID
      for (const session of sessions) {
        const isMatch = session.registryId === sessionId ||
                        session.id === sessionId ||
                        session.cliSessionId === sessionId;
        if (isMatch) {
          session.claimedTaskId = taskId;
          session.claimInfo = claim;
          break;
        }
      }
    }

    // Clear a session's claimed task when claim is released
    function clearSessionClaimedTask(sessionId, taskId) {
      for (const session of sessions) {
        const isMatch = session.registryId === sessionId ||
                        session.id === sessionId ||
                        session.cliSessionId === sessionId;
        if (isMatch && session.claimedTaskId === taskId) {
          session.claimedTaskId = null;
          session.claimInfo = null;
          break;
        }
      }
    }

    function connectSSE() {
      eventSource = new EventSource('/api/events');

      eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          let needsUIUpdate = false;

          // Handle taskData from SSE (real-time task updates)
          if (data.taskData) {
            const newStats = data.taskData.stats;
            const oldStats = tasksData?.stats;

            // Check if task data actually changed
            if (JSON.stringify(newStats) !== JSON.stringify(oldStats)) {
              tasksData = {
                tasks: [...(data.taskData.inProgress || []), ...(data.taskData.ready || [])],
                stats: newStats
              };
              needsUIUpdate = true;
            }
          }

          // Handle executionState from SSE (phase, quality scores)
          if (data.executionState) {
            const newScores = data.executionState.qualityScores;
            const oldScores = executionState?.qualityScores;

            // Check if execution state changed
            if (JSON.stringify(newScores) !== JSON.stringify(oldScores)) {
              executionState = data.executionState;
              needsUIUpdate = true;
            }
          }

          // If task/execution data changed, enrich sessions
          if (needsUIUpdate) {
            enrichActiveSession();
          }

          // Handle projects data from SSE - update existing sessions in-place to avoid bouncing
          if (data.projects) {
            let anyChanged = false;

            // Update CLI sessions in-place
            for (const p of data.projects) {
              // Filter out agent-* sessions (subagent tasks)
              const cliSessions = (p.sessions || []).filter(s => {
                const id = s.id || '';
                return !id.startsWith('agent-') && !id.includes('/agent-');
              });
              const defaultSessionId = `cli-${p.folder}-default`;

              // If we have real sessions, remove any "default" placeholder
              if (cliSessions.length > 0) {
                const defaultIdx = sessions.findIndex(s => s.id === defaultSessionId);
                if (defaultIdx >= 0) {
                  sessions.splice(defaultIdx, 1);
                  anyChanged = true;
                }
              }

              for (const cliSession of cliSessions) {
                // Skip agent sessions
                if (cliSession.id?.startsWith('agent-')) continue;

                const sessionId = `cli-${p.folder}-${cliSession.id}`;
                const existing = sessions.find(s => s.id === sessionId);

                // Consider session active if project active, session current, or recent activity
                const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
                const lastUpdateTime = typeof cliSession.lastUpdate === 'number' ? cliSession.lastUpdate : 0;
                const hasRecentActivity = lastUpdateTime > fiveMinutesAgo;
                const isActive = p.status === 'active' || cliSession.isActive || hasRecentActivity;
                // Use per-session context (fallback to project for backward compat)
                const newContextPercent = cliSession.contextPercent ?? p.metrics?.contextPercent ?? 0;
                const newCost = cliSession.cost ?? p.metrics?.cost ?? 0;
                const newModel = cliSession.model ?? p.metrics?.model;

                if (existing) {
                  // Update in-place - only mark changed if values actually differ
                  const oldStatus = existing.status;
                  existing.status = isActive ? 'active' : 'idle';
                  existing.contextPercent = newContextPercent;
                  existing.contextUsed = cliSession.contextUsed ?? p.metrics?.contextUsed ?? 0;
                  existing.cost = isActive ? newCost : 0;
                  // Use contextUsed to match statusline display
                  existing.tokens = cliSession.contextUsed ?? ((cliSession.inputTokens || 0) + (cliSession.outputTokens || 0) + (cliSession.cacheReadTokens || 0) + (cliSession.cacheCreationTokens || 0));
                  existing.model = newModel;
                  existing.messageCount = cliSession.messageCount || 0;
                  existing.safetyStatus = isActive ? p.safetyStatus : 'OK';
                  existing.lastUpdate = cliSession.lastUpdate;
                  if (oldStatus !== existing.status) anyChanged = true;
                } else {
                  // New session - add it
                  anyChanged = true;
                  sessions.push({
                    id: sessionId,
                    project: p.name,
                    path: p.path,
                    folder: p.folder,
                    cliSessionId: cliSession.id,
                    sessionType: 'cli',
                    status: isActive ? 'active' : 'idle',
                    contextPercent: newContextPercent,
                    contextUsed: cliSession.contextUsed ?? p.metrics?.contextUsed ?? 0,
                    cost: isActive ? newCost : 0,
                    // Use contextUsed (includes cache tokens) to match statusline display
                    tokens: cliSession.contextUsed ?? ((cliSession.inputTokens || 0) + (cliSession.outputTokens || 0) + (cliSession.cacheReadTokens || 0) + (cliSession.cacheCreationTokens || 0)),
                    model: newModel,
                    messageCount: cliSession.messageCount || 0,
                    safetyStatus: isActive ? p.safetyStatus : 'OK',
                    qualityScore: 0,
                    qualityBreakdown: {},
                    currentTask: null,
                    taskQueue: [],
                    taskStats: {},
                    phase: null,
                    iteration: 1,
                    autonomous: false,
                    logSessionId: null,
                    orchestratorInfo: null,
                    confidenceScore: null,
                    registryId: null,
                    lastUpdate: cliSession.lastUpdate,
                    startTime: cliSession.lastUpdate
                  });
                }
              }

              // Only create default session if no real CLI sessions exist
              if (cliSessions.length === 0) {
                const existing = sessions.find(s => s.id === defaultSessionId);
                const newContextPercent = p.metrics?.contextPercent || 0;

                if (existing) {
                  const oldStatus = existing.status;
                  existing.status = p.status === 'active' ? 'active' : 'idle';
                  existing.contextPercent = newContextPercent;
                  existing.cost = p.metrics?.cost || 0;
                  existing.tokens = p.metrics?.contextUsed || 0;
                  existing.messageCount = p.metrics?.messageCount || 0;
                  existing.safetyStatus = p.safetyStatus;
                  existing.lastUpdate = p.metrics?.lastUpdate;
                  if (oldStatus !== existing.status) anyChanged = true;
                } else {
                  anyChanged = true;
                  sessions.push({
                    id: defaultSessionId,
                    project: p.name,
                    path: p.path,
                    folder: p.folder,
                    cliSessionId: 'default',
                    sessionType: 'cli',
                    status: p.status === 'active' ? 'active' : 'idle',
                    contextPercent: newContextPercent,
                    cost: p.metrics?.cost || 0,
                    tokens: p.metrics?.contextUsed || 0,
                    model: p.metrics?.model,
                    messageCount: p.metrics?.messageCount || 0,
                    safetyStatus: p.safetyStatus,
                    qualityScore: 0,
                    qualityBreakdown: {},
                    currentTask: null,
                    taskQueue: [],
                    taskStats: {},
                    phase: null,
                    iteration: 1,
                    autonomous: false,
                    logSessionId: null,
                    orchestratorInfo: null,
                    confidenceScore: null,
                    registryId: null,
                    lastUpdate: p.metrics?.lastUpdate,
                    startTime: p.metrics?.lastUpdate
                  });
                }
              }
            }

            // Update UI only if something actually changed (throttled to reduce jumping)
            if (anyChanged || needsUIUpdate) {
              throttledUIUpdate();
            }
          }

          // Handle hierarchy updates from SSE
          if (data.hierarchyUpdate) {
            const update = data.hierarchyUpdate;
            // Refresh hierarchy if it's for the currently selected session
            if (update.sessionId === HierarchyTreeState.currentSessionId) {
              if (update.type === 'full') {
                // Full refresh
                loadHierarchy(update.sessionId);
              } else if (update.type === 'node' && update.node) {
                // Incremental update - update specific node
                const existingNode = HierarchyTreeState.getNode(update.node.id);
                if (existingNode) {
                  existingNode.status = normalizeHierarchyStatus(update.node.status);
                  existingNode.metrics = update.node.metrics || existingNode.metrics;
                  // Re-render just that node's status
                  const nodeEl = document.querySelector(`[data-node-id="${update.node.id}"]`);
                  if (nodeEl) {
                    const statusDot = nodeEl.querySelector('.hierarchy-tree__status-dot');
                    if (statusDot) {
                      statusDot.className = `hierarchy-tree__status-dot hierarchy-tree__status-dot--${existingNode.status}`;
                    }
                  }
                }
              }
            }
          }

          // Handle claim events from SSE (task:claimed, task:released, task:claim-expired, etc.)
          if (data.claimEvent) {
            const event = data.claimEvent;
            handleClaimEvent(event);
          }
        } catch (err) {
          console.error('SSE parse error:', err);
        }
      };

      eventSource.onerror = () => {
        const dot = document.getElementById('connectionDot');
        if (dot) dot.style.background = 'var(--color-danger)';
        setTimeout(() => {
          eventSource.close();
          connectSSE();
        }, 3000);
      };

      eventSource.onopen = () => {
        const dot = document.getElementById('connectionDot');
        if (dot) dot.style.background = 'var(--color-success)';
      };
    }

    // ===== TRAFFIC LIGHTS =====
    function updateTrafficLights() {
      const container = document.getElementById('trafficLights');
      const summary = document.getElementById('statusSummary');

      // v4: These elements may not exist - skip if not found
      if (!container) return;

      let healthy = 0, warning = 0, critical = 0, idle = 0, cli = 0;

      container.innerHTML = sessions.map(s => {
        const quality = s.qualityScore || 0;
        const isIdle = s.status === 'idle' || s.status === 'paused';
        const isAutonomous = s.autonomous || s.isAutonomous;

        let statusClass, tooltipText;
        if (!isAutonomous) {
          // CLI sessions don't have quality tracking - always show as idle/gray
          statusClass = 'idle';
          tooltipText = `${s.project}: CLI (no quality tracking)`;
          cli++;
        } else if (isIdle) {
          statusClass = 'idle';
          tooltipText = `${s.project}: Idle`;
          idle++;
        } else if (quality >= 85) {
          statusClass = 'excellent';
          tooltipText = `${s.project}: ${quality}`;
          healthy++;
        } else if (quality >= 75) {
          statusClass = 'good';
          tooltipText = `${s.project}: ${quality}`;
          healthy++;
        } else if (quality >= 50) {
          statusClass = 'warning';
          tooltipText = `${s.project}: ${quality}`;
          warning++;
        } else {
          statusClass = 'critical';
          tooltipText = `${s.project}: ${quality}`;
          critical++;
        }

        return `
          <div class="traffic-light ${statusClass}" onclick="selectSession('${s.id}')" title="${s.project}">
            <div class="traffic-light-tooltip">${tooltipText}</div>
          </div>
        `;
      }).join('');

      // Build summary - only show quality counts for autonomous sessions
      const parts = [];
      if (healthy) parts.push(`${healthy} healthy`);
      if (warning) parts.push(`${warning} warning`);
      if (critical) parts.push(`${critical} critical`);
      if (idle) parts.push(`${idle} idle`);
      if (cli) parts.push(`${cli} CLI`);

      // If all sessions are CLI, indicate no quality tracking
      if (cli === sessions.length && sessions.length > 0) {
        summary.textContent = `${sessions.length} CLI sessions (no quality tracking)`;
      } else {
        summary.textContent = `${sessions.length} sessions: ${parts.join(', ') || 'none'}`;
      }
    }

    // ===== SESSION LIST =====
    // Track collapsed groups
    const collapsedGroups = new Set();

    // Throttle UI updates to prevent jumping
    let lastUIUpdate = 0;
    const UI_UPDATE_THROTTLE = 500; // ms
    let pendingUIUpdate = null;

    function throttledUIUpdate() {
      const now = Date.now();
      if (now - lastUIUpdate >= UI_UPDATE_THROTTLE) {
        lastUIUpdate = now;
        updateTrafficLights();
        updateSessionList();
        if (selectedSessionId) {
          updateDetailPanel();
        }
      } else if (!pendingUIUpdate) {
        pendingUIUpdate = setTimeout(() => {
          pendingUIUpdate = null;
          lastUIUpdate = Date.now();
          updateTrafficLights();
          updateSessionList();
          if (selectedSessionId) {
            updateDetailPanel();
          }
        }, UI_UPDATE_THROTTLE - (now - lastUIUpdate));
      }
    }

    function toggleGroup(project) {
      if (collapsedGroups.has(project)) {
        collapsedGroups.delete(project);
      } else {
        collapsedGroups.add(project);
      }
      updateSessionList();
    }

    function renderSessionItem(s) {
      const quality = s.qualityScore || 0;
      const isIdle = s.status === 'idle' || s.status === 'paused';
      const isAutonomous = s.autonomous || s.isAutonomous;
      const isSelected = s.id === selectedSessionId;

      // CLI sessions don't have quality tracking - show NA
      let qualityClass;
      let qualityDisplay;
      if (!isAutonomous) {
        qualityClass = 'idle';
        qualityDisplay = 'NA';
      } else if (isIdle) {
        qualityClass = 'idle';
        qualityDisplay = '--';
      } else if (quality >= 85) {
        qualityClass = 'excellent';
        qualityDisplay = quality;
      } else if (quality >= 75) {
        qualityClass = 'good';
        qualityDisplay = quality;
      } else if (quality >= 50) {
        qualityClass = 'warning';
        qualityDisplay = quality;
      } else {
        qualityClass = 'critical';
        qualityDisplay = quality;
      }

      let borderClass = '';
      if (isAutonomous && !isIdle && quality < 50) borderClass = 'critical';
      else if (isAutonomous && !isIdle && quality < 75) borderClass = 'warning';

      // Format session ID for display - use short sequential ID (S1, S2, S3...)
      const sessionIdShort = getShortSessionId(s.id);
      const sessionTypeLabel = isAutonomous ? 'AUTO' : 'CLI';
      const sessionTypeBadgeClass = isAutonomous ? 'autonomous' : 'cli';

      // Format time
      const timeAgo = s.lastUpdate ? formatTimeAgo(s.lastUpdate) : '';

      // Phase 4: Use claimed task for per-session display
      // Priority: claimedTaskId > currentTask.id > next in queue
      const claimedTaskId = s.claimedTaskId;
      const claimInfo = s.claimInfo;
      const claimIsStale = claimInfo && isClaimStale(claimInfo);

      // Determine what task to show for this session
      let taskDisplay = '';
      let claimIndicator = '';

      if (claimedTaskId) {
        // Session has a claimed task
        taskDisplay = claimedTaskId;
        if (claimIsStale) {
          claimIndicator = '<span class="claim-indicator stale" title="Claim may be stale"></span>';
        } else {
          claimIndicator = '<span class="claim-indicator owned" title="Claimed by this session"></span>';
        }
      } else if (s.currentTask?.id) {
        // Fall back to currentTask from project data
        taskDisplay = s.currentTask.id;
      } else if (s.taskQueue?.length) {
        taskDisplay = `Next: ${s.taskQueue[0].id}`;
      } else {
        taskDisplay = 'No active task';
      }

      const taskPhase = s.currentTask?.phase || s.phase;

      return `
        <div class="session-item ${borderClass} ${isSelected ? 'selected' : ''}"
             onclick="selectSession('${s.id}')"
             role="option"
             tabindex="0"
             aria-selected="${isSelected}"
             aria-label="${s.project} ${sessionTypeLabel} session, quality ${qualityDisplay}"
             onkeydown="if(event.key==='Enter'||event.key===' ')selectSession('${s.id}')">
          <div class="session-header">
            <span class="session-name">
              <span class="session-type-badge ${sessionTypeBadgeClass}">${sessionTypeLabel}</span>
              ${s.project}
            </span>
            <span class="quality-badge ${qualityClass}" aria-label="Quality score ${qualityDisplay}">${qualityDisplay}</span>
          </div>
          <div class="session-task">
            ${taskDisplay}${claimIndicator}
            ${taskPhase ? `<span class="phase-badge ${taskPhase}">${taskPhase}</span>` : ''}
            ${s.iteration > 1 ? `<span style="font-size:10px;color:var(--text-muted)">iter ${s.iteration}</span>` : ''}
          </div>
          <div class="session-metrics">
            <span class="session-id-text" title="Session ID">${sessionIdShort}</span>
            <span title="Context used">${Math.round(s.contextPercent || 0)}% ctx</span>
            ${s.taskStats?.total ? `<span title="Task completion">${s.taskStats.byStatus?.completed || 0}/${s.taskStats.total} tasks</span>` : ''}
            ${timeAgo ? `<span title="Last update">${timeAgo}</span>` : ''}
            ${settings.showCost ? `<span title="Cost">$${(s.cost || 0).toFixed(2)}</span>` : ''}
          </div>
          <div class="session-controls" onclick="event.stopPropagation()">
            ${s.registryId ? `
              <button class="control-btn pause" onclick="togglePause('${s.id}')" aria-label="${s.status === 'paused' ? 'Resume session' : 'Pause session'}">
                ${s.status === 'paused' ? '' : ''}
              </button>
              <button class="control-btn skip" onclick="skipTask('${s.id}')" aria-label="Skip current task"></button>
              <button class="control-btn end" onclick="endSession('${s.id}')" aria-label="End session"></button>
            ` : `
              <button class="control-btn pause" disabled title="CLI sessions cannot be controlled remotely"></button>
              <button class="control-btn skip" disabled title="CLI sessions cannot be controlled remotely"></button>
              <button class="control-btn end" disabled title="CLI sessions cannot be controlled remotely"></button>
            `}
          </div>
        </div>
      `;
    }

    function formatTimeAgo(timestamp) {
      if (!timestamp) return '';
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return `${seconds}s ago`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    function updateSessionList() {
      const container = document.getElementById('sessionList');
      const countEl = document.getElementById('sessionCount');

      // Safety check
      if (!container) {
        console.error('[Dashboard] sessionList container not found');
        return;
      }

      // Preserve scroll position
      const scrollTop = container.scrollTop;

      // Debug: log session count
      console.log('[Dashboard] updateSessionList called, sessions:', sessions.length);

      // If no sessions, show message
      if (!sessions || sessions.length === 0) {
        container.innerHTML = '<div style="padding: 12px; color: var(--text-muted); font-size: 11px;">No sessions found</div>';
        if (countEl) countEl.textContent = '0';
        return;
      }

      // Get filter settings (with safe defaults)
      const activeOnly = document.getElementById('filterActiveOnly')?.checked ?? false;
      const showCli = document.getElementById('filterShowCli')?.checked ?? true;
      const showAuto = document.getElementById('filterShowAuto')?.checked ?? true;
      const groupByProject = document.getElementById('filterGroupByProject')?.checked ?? true;

      // Apply filters and sort (active first, then by most recent)
      const filteredSessions = sessions.filter(s => {
        const isActive = s.status === 'active';
        const isAutonomous = s.autonomous || s.isAutonomous;

        if (activeOnly && !isActive) return false;
        if (!showCli && !isAutonomous) return false;
        if (!showAuto && isAutonomous) return false;

        return true;
      }).sort((a, b) => {
        // Active first, then by most recent
        const aActive = a.status === 'active' ? 1 : 0;
        const bActive = b.status === 'active' ? 1 : 0;
        if (aActive !== bActive) return bActive - aActive;
        return (b.lastUpdate || 0) - (a.lastUpdate || 0);
      });

      console.log('[Dashboard] filteredSessions:', filteredSessions.length);

      // Time thresholds for activity
      const now = Date.now();
      const thirtyMinsAgo = now - (30 * 60 * 1000);  // 30 minutes for project visibility
      const tenMinsAgo = now - (10 * 60 * 1000);     // 10 minutes for session visibility

      if (groupByProject) {
        // Group sessions by project
        const groups = {};
        for (const s of filteredSessions) {
          const key = s.project || 'Unknown';
          if (!groups[key]) groups[key] = [];
          groups[key].push(s);
        }

        // Filter to only active projects (has session active in last 30 mins)
        const activeGroups = Object.entries(groups).filter(([, projectSessions]) => {
          return projectSessions.some(s => (s.lastUpdate || 0) > thirtyMinsAgo);
        });

        // Sort groups by: has active session, then by most recent update in group
        const sortedGroups = activeGroups.sort(([, sessionsA], [, sessionsB]) => {
          const aHasActive = sessionsA.some(s => s.status === 'active') ? 1 : 0;
          const bHasActive = sessionsB.some(s => s.status === 'active') ? 1 : 0;
          if (aHasActive !== bHasActive) return bHasActive - aHasActive;
          const aMaxUpdate = Math.max(...sessionsA.map(s => s.lastUpdate || 0));
          const bMaxUpdate = Math.max(...sessionsB.map(s => s.lastUpdate || 0));
          return bMaxUpdate - aMaxUpdate;
        });

        // Count visible sessions
        let visibleCount = 0;

        // Render grouped
        container.innerHTML = sortedGroups.map(([project, projectSessions]) => {
          // Within active projects, only show sessions active in last 10 mins
          const recentSessions = projectSessions.filter(s => (s.lastUpdate || 0) > tenMinsAgo);
          const hiddenCount = projectSessions.length - recentSessions.length;

          visibleCount += recentSessions.length;

          // Skip if no recent sessions (shouldn't happen since project is active)
          if (recentSessions.length === 0) return '';

          const activeCount = recentSessions.filter(s => s.status === 'active').length;

          // Only collapse if user manually collapsed it
          const isCollapsed = collapsedGroups.has(project);

          return `
            <div class="session-group ${isCollapsed ? 'collapsed' : ''}" data-project="${project}">
              <div class="session-group-header" onclick="toggleGroup('${project}')">
                <span class="session-group-toggle"></span>
                <span>${project}</span>
                <span class="session-group-count">${activeCount > 0 ? `${activeCount} active` : 'idle'}${hiddenCount > 0 ? ` (+${hiddenCount} older)` : ''}</span>
              </div>
              <div class="session-group-items">
                ${recentSessions.map(s => renderSessionItem(s)).join('')}
              </div>
            </div>
          `;
        }).join('');

        countEl.textContent = `${visibleCount}/${sessions.length}`;
      } else {
        // Render flat list - only show sessions active in last 10 mins
        const recentSessions = filteredSessions.filter(s => (s.lastUpdate || 0) > tenMinsAgo);
        container.innerHTML = recentSessions.map(s => renderSessionItem(s)).join('');
        countEl.textContent = `${recentSessions.length}/${sessions.length}`;
      }

      // Restore scroll position
      container.scrollTop = scrollTop;
    }

    // ===== DETAIL PANEL =====
    function selectSession(id) {
      selectedSessionId = id;
      updateSessionList(); // Update selection highlight
      updateDetailPanel();
      // v4: Update tab panes with selected session data
      const session = sessions.find(s => s.id === id);
      updateAllTabPanes(session);
    }

    function updateDetailPanel() {
      const session = sessions.find(s => s.id === selectedSessionId);
      const emptyEl = document.getElementById('detailEmpty');
      const contentEl = document.getElementById('detailContent');

      // v4: These elements may not exist - skip if not found
      if (!emptyEl || !contentEl) return;

      if (!session) {
        emptyEl.style.display = 'flex';
        contentEl.style.display = 'none';
        return;
      }

      // Preserve scroll positions and log content
      const detailContentEl = contentEl.querySelector('.detail-content');
      const detailScrollTop = detailContentEl ? detailContentEl.scrollTop : 0;
      const logContentEl = document.getElementById('logContent');
      const logScrollTop = logContentEl ? logContentEl.scrollTop : 0;
      const logWasAtBottom = logContentEl ? (logContentEl.scrollHeight - logContentEl.scrollTop <= logContentEl.clientHeight + 50) : true;
      // Preserve log content HTML to avoid losing "No logs" message on panel refresh
      const preservedLogContent = logContentEl ? logContentEl.innerHTML : null;

      emptyEl.style.display = 'none';
      contentEl.style.display = 'flex';

      const quality = session.qualityScore || 0;
      const isIdle = session.status === 'idle' || session.status === 'paused';
      const prediction = predictions[session.project] || {};
      const isAutonomous = session.autonomous || session.isAutonomous;

      // CLI sessions don't have quality tracking - show NA
      let qualityClass = 'health';
      let qualityDisplay;
      if (!isAutonomous) {
        qualityDisplay = 'NA';
      } else if (isIdle) {
        qualityDisplay = '--';
      } else {
        qualityDisplay = quality;
        if (quality < 50) qualityClass = 'critical';
        else if (quality < 75) qualityClass = 'warning';
      }

      // Build quality breakdown tooltip
      const qualityBreakdown = session.qualityBreakdown || {};
      const breakdownText = isAutonomous ? Object.entries(qualityBreakdown)
        .map(([k, v]) => `${k}: ${v}`)
        .join(', ') : 'Quality tracking only available for autonomous sessions';

      const metricsHTML = `
        <div class="metric-card ${qualityClass}">
          <div class="metric-label">Quality Score</div>
          <div class="metric-value ${isAutonomous && quality >= 75 ? 'success' : isAutonomous && quality >= 50 ? 'warning' : ''}"
               title="${breakdownText}">
            ${qualityDisplay}
          </div>
          ${isAutonomous && breakdownText && Object.keys(qualityBreakdown).length ? `<div class="metric-detail" style="font-size:10px;max-width:150px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${breakdownText}">${Object.keys(qualityBreakdown).length} criteria scored</div>` : ''}
        </div>
        <div class="metric-card">
          <div class="metric-label">Context Used</div>
          <div class="metric-value">${Math.round(session.contextPercent || 0)}%</div>
          ${settings.showExhaustionETA && prediction.minutesToExhaustion
            ? `<div class="metric-detail">Exhaustion in ~${prediction.minutesToExhaustion}m</div>`
            : `<div class="metric-detail">${session.tokens ? (session.tokens/1000).toFixed(1) + 'k tokens' : 'Healthy pace'}</div>`}
        </div>
        <div class="metric-card">
          <div class="metric-label">Phase / Iteration</div>
          <div class="metric-value" style="font-size: 18px;">${session.phase || session.currentTask?.phase || 'Idle'}</div>
          <div class="metric-detail">Iteration ${session.iteration || 1}</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Task Progress</div>
          <div class="metric-value" style="font-size: 18px;">${session.taskStats?.byStatus?.completed || 0}/${session.taskStats?.total || 0}</div>
          <div class="metric-detail">${session.taskQueue?.length || 0} ready, ${session.taskStats?.byStatus?.blocked || 0} blocked</div>
        </div>
      `;

      const task = session.currentTask || {};
      const acceptance = task.acceptance || [];
      // Normalize acceptance criteria - handle both string and object formats
      const normalizedAcceptance = acceptance.map(a => {
        if (typeof a === 'string') {
          // If task is completed, mark all criteria as done
          return { text: a, done: task.status === 'completed' };
        }
        return { text: a.text || a, done: a.done || task.status === 'completed' };
      });
      const completedCriteria = normalizedAcceptance.filter(a => a.done).length;

      const taskHTML = task.id ? `
        <div class="task-card">
          <div class="task-header">
            <span class="task-title">${task.title || task.id}</span>
            <span class="phase-badge ${task.phase || ''}">${task.phase || 'unknown'}</span>
          </div>
          <div class="task-meta">
            <span>Priority: ${task.priority || 'normal'}</span>
            <span>Estimate: ${task.estimate || '--'}</span>
            ${settings.showErrorCount ? `<span>Attempts: ${task.attempts || 1}</span>` : ''}
          </div>
          ${renderPhaseProgression(task.id, task.phase)}
          ${settings.showAcceptanceProgress ? `
          <ul class="acceptance-list">
            ${normalizedAcceptance.map(a => `
              <li class="acceptance-item ${a.done ? 'done' : ''}">
                <span class="check">${a.done ? '' : ''}</span>
                ${a.text}
              </li>
            `).join('')}
          </ul>
          ` : ''}
        </div>
      ` : '<div class="task-card" style="text-align: center; color: var(--text-muted);">No active task</div>';

      const queue = session.taskQueue || [];
      const sessionRegistryId = session.registryId || session.cliSessionId || session.id;

      // Render queue with claim badges
      const queueHTML = queue.length ? `
        <div class="queue-filters">
          <button class="queue-filter-btn ${queueFilter === 'all' ? 'active' : ''}" onclick="setQueueFilter('all')">All</button>
          <button class="queue-filter-btn ${queueFilter === 'available' ? 'active' : ''}" onclick="setQueueFilter('available')">Available</button>
          <button class="queue-filter-btn ${queueFilter === 'claimed' ? 'active' : ''}" onclick="setQueueFilter('claimed')">Claimed</button>
          <button class="queue-filter-btn ${queueFilter === 'mine' ? 'active' : ''}" onclick="setQueueFilter('mine')">Mine</button>
        </div>
        <div class="queue-list">
          ${queue.slice(0, 8).map((t, i) => {
            const claimStatus = getClaimStatus(t.id, sessionRegistryId);
            const claimClass = claimStatus.status === 'mine' ? 'claimed-by-me' :
                               claimStatus.status === 'stale' ? 'stale-claim' :
                               claimStatus.status === 'claimed' ? 'claimed' : '';

            // Apply filter
            if (queueFilter === 'available' && claimStatus.status !== 'available') return '';
            if (queueFilter === 'claimed' && claimStatus.status === 'available') return '';
            if (queueFilter === 'mine' && claimStatus.status !== 'mine') return '';

            const claimBadge = renderClaimBadge(claimStatus);

            return `
            <div class="queue-item ${i === 0 ? 'next' : ''} ${claimClass}">
              <span class="queue-number">${i + 1}</span>
              <span class="queue-task" title="${t.title || t.id}">
                ${t.id}
                ${t.phase ? '<span class="phase-badge ' + t.phase + '" style="margin-left:6px">' + t.phase + '</span>' : ''}
              </span>
              ${claimBadge}
              <span class="queue-priority ${t.priority || ''}">${t.priority || 'normal'}</span>
            </div>
          `;}).filter(Boolean).join('')}
          ${queue.length > 8 ? '<div class="queue-item" style="justify-content:center;color:var(--text-muted)">+' + (queue.length - 8) + ' more</div>' : ''}
        </div>
        <div class="claim-stats">
          <span class="claim-stat"><span class="claim-stat-dot available"></span>${queue.filter(t => !getClaimForTask(t.id)).length} available</span>
          <span class="claim-stat"><span class="claim-stat-dot claimed"></span>${queue.filter(t => getClaimForTask(t.id)).length} claimed</span>
        </div>
      ` : '<div style="color: var(--text-muted); text-align: center; padding: 20px;">No tasks in queue. All caught up!</div>';

      contentEl.innerHTML = `
        <div class="detail-header">
          <div class="detail-title">
            ${session.project}
            ${isAutonomous ? '<span title="Autonomous Session"></span>' : ''}
          </div>
          <div class="detail-actions">
            <button class="detail-btn" onclick="togglePause('${session.id}')">
              ${session.status === 'paused' ? 'Resume' : 'Pause'}
            </button>
            <button class="detail-btn" onclick="skipTask('${session.id}')">Skip Task</button>
            <button class="detail-btn danger" onclick="endSession('${session.id}')">End Session</button>
          </div>
        </div>

        <div class="metrics-grid">
          ${metricsHTML}
        </div>

        <div class="detail-content">
          <div class="detail-section">
            <h3>Current Task</h3>
            ${taskHTML}
          </div>

          <div class="detail-section">
            <h3>Task Queue</h3>
            ${queueHTML}
          </div>

          <div class="detail-section">
            <h3>Agent Hierarchy</h3>
            <div class="hierarchy-panel">
              <div class="hierarchy-panel-header">
                <span class="hierarchy-panel-title">Delegation Tree</span>
                <div class="hierarchy-panel-actions">
                  <button onclick="expandAllHierarchy()">Expand</button>
                  <button onclick="collapseAllHierarchy()">Collapse</button>
                  <button onclick="refreshHierarchy('${session.id}')">Refresh</button>
                </div>
              </div>
              <div class="hierarchy-panel-body" id="hierarchyTreeContainer">
                <div class="hierarchy-empty">
                  <div class="hierarchy-empty-icon">Loading...</div>
                </div>
              </div>
            </div>
          </div>

          <div class="detail-section">
            <h3>Lessons Learned</h3>
            <div class="lessons-section" id="lessonsSection">
              <div class="lessons-header" onclick="toggleLessons()">
                <span class="lessons-title">Session Notes & Learnings</span>
                <span class="lessons-count" id="lessonsCount">0 notes</span>
                <span id="lessonsToggleIcon"></span>
              </div>
              <div class="lessons-content" id="lessonsContent" style="display: none;">
                <div class="lessons-empty">No lessons recorded yet</div>
              </div>
            </div>
          </div>

          <div class="detail-section">
            <h3>Live Logs</h3>
            <div class="log-section">
              <div class="log-header" onclick="toggleLogs()">
                <span class="log-title">
                  <span class="log-streaming-dot"></span>
                  Session Logs
                </span>
                <span id="logToggleIcon"></span>
              </div>
              <div class="log-content" id="logContent">
                <div class="log-line info">[${new Date().toLocaleTimeString()}] Connected to session...</div>
              </div>
            </div>
          </div>
        </div>
      `;

      // Start log streaming for selected session (only if session changed)
      // Use logSessionId if available (maps to actual log file), fallback to session.id
      const logId = session.logSessionId != null ? session.logSessionId : session.id;
      const sessionChanged = logId && (!logEventSource || logEventSource.sessionId !== logId);

      // Restore scroll positions and log content after DOM update
      requestAnimationFrame(() => {
        const newDetailContent = contentEl.querySelector('.detail-content');
        if (newDetailContent && detailScrollTop > 0) {
          newDetailContent.scrollTop = detailScrollTop;
        }
        const newLogContent = document.getElementById('logContent');
        if (newLogContent) {
          // If session didn't change and we have preserved content, restore it
          if (!sessionChanged && preservedLogContent) {
            newLogContent.innerHTML = preservedLogContent;
          }
          if (logWasAtBottom) {
            // If was at bottom, stay at bottom (for auto-scroll)
            newLogContent.scrollTop = newLogContent.scrollHeight;
          } else if (logScrollTop > 0) {
            newLogContent.scrollTop = logScrollTop;
          }
        }
      });

      // Only start log stream if session changed
      if (sessionChanged) {
        startLogStream(logId);
      }

      // Load hierarchy for selected session
      loadHierarchy(session.id);
    }

    // ===== USAGE DISPLAY =====
    function updateUsageDisplay() {
      // v4: Usage display elements may not exist - skip if not found
      if (!document.getElementById('usagePercent')) return;

      const fiveHour = usageLimits.fiveHour || {};
      const daily = usageLimits.daily || {};
      const weekly = usageLimits.weekly || {};

      // Main badge
      const mainPercent = fiveHour.percent || 0;
      document.getElementById('usagePercent').textContent = `${mainPercent}%`;
      const fillEl = document.getElementById('usageBarFill');
      fillEl.style.width = `${mainPercent}%`;
      fillEl.className = 'bar-fill' + (mainPercent >= 90 ? ' critical' : mainPercent >= 75 ? ' warning' : '');

      // 5-hour
      document.getElementById('usage5h').textContent = `${fiveHour.used || 0}/${fiveHour.limit || 300}`;
      const fill5h = document.getElementById('usage5hFill');
      fill5h.style.width = `${fiveHour.percent || 0}%`;
      fill5h.className = 'usage-limit-fill' + (fiveHour.percent >= 90 ? ' critical' : fiveHour.percent >= 75 ? ' warning' : '');
      document.getElementById('usage5hMeta').textContent = `Resets in ${fiveHour.resetIn || '--'}`;

      // Daily
      document.getElementById('usageDaily').textContent = `${daily.used || 0}/${daily.limit || 1500}`;
      const fillDaily = document.getElementById('usageDailyFill');
      fillDaily.style.width = `${daily.percent || 0}%`;
      fillDaily.className = 'usage-limit-fill' + (daily.percent >= 90 ? ' critical' : daily.percent >= 75 ? ' warning' : '');
      document.getElementById('usageDailyMeta').textContent = `Resets in ${daily.resetIn || '--'}`;

      // Weekly
      document.getElementById('usageWeekly').textContent = `${weekly.used || 0}/${weekly.limit || 7000}`;
      const fillWeekly = document.getElementById('usageWeeklyFill');
      fillWeekly.style.width = `${weekly.percent || 0}%`;
      fillWeekly.className = 'usage-limit-fill' + (weekly.percent >= 90 ? ' critical' : weekly.percent >= 75 ? ' warning' : '');
      document.getElementById('usageWeeklyMeta').textContent = `Resets on ${weekly.resetDay || '--'}`;
    }

    // ===== SESSION CONTROLS =====
    // Helper to get registry ID for session control operations
    function getSessionRegistryId(id) {
      const session = sessions.find(s => s.id === id);
      if (!session) return null;
      // Use registryId for autonomous sessions (numeric ID in SessionRegistry)
      // CLI sessions don't have registryId and can't be controlled remotely
      return session.registryId;
    }

    async function togglePause(id) {
      const session = sessions.find(s => s.id === id);
      if (!session) return;

      const registryId = getSessionRegistryId(id);
      if (!registryId) {
        showToast('warning', 'Not Available', 'CLI sessions cannot be paused remotely. Use Ctrl+C in the terminal.');
        return;
      }

      const action = session.status === 'paused' ? 'resume' : 'pause';
      try {
        const res = await fetch(`/api/sessions/${registryId}/${action}`, { method: 'POST' });
        if (!res.ok) {
          const data = await res.json();
          showToast('error', 'Failed', data.error || `Failed to ${action} session`);
          return;
        }
        fetchSessions();
      } catch (err) {
        console.error(`Failed to ${action} session:`, err);
        showToast('error', 'Error', err.message);
      }
    }

    async function skipTask(id) {
      const registryId = getSessionRegistryId(id);
      if (!registryId) {
        showToast('warning', 'Not Available', 'CLI sessions cannot skip tasks remotely.');
        return;
      }

      if (!confirm('Skip current task and move to next?')) return;
      try {
        const res = await fetch(`/api/sessions/${registryId}/skip-task`, { method: 'POST' });
        if (!res.ok) {
          const data = await res.json();
          showToast('error', 'Failed', data.error || 'Failed to skip task');
          return;
        }
        fetchSessions();
      } catch (err) {
        console.error('Failed to skip task:', err);
        showToast('error', 'Error', err.message);
      }
    }

    async function endSession(id) {
      const registryId = getSessionRegistryId(id);
      if (!registryId) {
        showToast('warning', 'Not Available', 'CLI sessions cannot be ended remotely. Use Ctrl+C in the terminal.');
        return;
      }

      if (!confirm('End this session? This cannot be undone.')) return;
      try {
        const res = await fetch(`/api/sessions/${registryId}/end`, { method: 'POST' });
        if (!res.ok) {
          const data = await res.json();
          showToast('error', 'Failed', data.error || 'Failed to end session');
          return;
        }
        if (selectedSessionId === id) {
          selectedSessionId = null;
        }
        fetchSessions();
      } catch (err) {
        console.error('Failed to end session:', err);
        showToast('error', 'Error', err.message);
      }
    }

    // ===== LOG STREAMING =====
    let logEventSource = null;

    async function startLogStream(sessionId) {
      if (logEventSource) {
        logEventSource.close();
        logEventSource = null;
      }

      const logContent = document.getElementById('logContent');
      if (!logContent) return;

      // Clear existing logs
      logContent.innerHTML = '';

      // First, fetch historical logs
      let hasLogs = false;
      try {
        const historyRes = await fetch(`/api/logs/${sessionId}/history?lines=50`);
        if (historyRes.ok) {
          const history = await historyRes.json();
          if (history.entries && history.entries.length > 0) {
            hasLogs = true;
            history.entries.forEach(entry => {
              const line = document.createElement('div');
              line.className = 'log-line ' + (entry.level || '').toLowerCase();
              line.textContent = `[${entry.timestamp || ''}] ${entry.line || entry.raw || ''}`;
              logContent.appendChild(line);
            });
            logContent.scrollTop = logContent.scrollHeight;
          }
        }
      } catch (err) {
        console.log('No historical logs available');
      }

      // If no logs found, show helpful message
      if (!hasLogs) {
        const msg = document.createElement('div');
        msg.className = 'log-line info';
        msg.style.color = '#888';
        msg.style.fontStyle = 'italic';
        msg.innerHTML = 'No session logs available.<br><span style="font-size: 11px;">Logs appear when running the autonomous orchestrator (npm run autonomous)</span>';
        logContent.appendChild(msg);
      }

      // Then start SSE stream for new logs
      logEventSource = new EventSource(`/api/logs/${sessionId}/stream`);
      logEventSource.sessionId = sessionId;

      logEventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          // If we showed the "no logs" message, clear it
          if (!hasLogs && logContent.children.length === 1) {
            logContent.innerHTML = '';
            hasLogs = true;
          }
          const line = document.createElement('div');
          line.className = 'log-line ' + (data.level || '').toLowerCase();
          line.textContent = `[${new Date(data.timestamp).toLocaleTimeString()}] ${data.line || data.message}`;
          logContent.appendChild(line);
          logContent.scrollTop = logContent.scrollHeight;

          // Keep only last 100 lines
          while (logContent.children.length > 100) {
            logContent.removeChild(logContent.firstChild);
          }
        } catch (err) {
          // Ignore parse errors
        }
      };
    }

    function toggleLogs() {
      const content = document.getElementById('logContent');
      const icon = document.getElementById('logToggleIcon');
      if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.textContent = '';
      } else {
        content.style.display = 'none';
        icon.textContent = '';
      }
    }

    function toggleLessons() {
      const content = document.getElementById('lessonsContent');
      const icon = document.getElementById('lessonsToggleIcon');
      if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.textContent = '';
        fetchLessons();
      } else {
        content.style.display = 'none';
        icon.textContent = '';
      }
    }

    async function fetchLessons() {
      if (!selectedSessionId) return;

      const session = sessions.find(s => s.id === selectedSessionId);
      if (!session) return;

      try {
        // Fetch lessons from memory store or task notes
        const res = await fetch(`/api/lessons/${session.project}`);
        if (!res.ok) {
          // If endpoint doesn't exist, show placeholder
          updateLessonsUI([]);
          return;
        }
        const data = await res.json();
        // API returns { projectId, lessons, count }
        updateLessonsUI(data.lessons || []);
      } catch (err) {
        // Endpoint may not exist yet - show placeholder
        updateLessonsUI([]);
      }
    }

    function updateLessonsUI(lessons) {
      const content = document.getElementById('lessonsContent');
      const count = document.getElementById('lessonsCount');

      if (!lessons || lessons.length === 0) {
        content.innerHTML = '<div class="lessons-empty">No lessons recorded yet. Notes will appear here as tasks complete.</div>';
        count.textContent = '0 notes';
        return;
      }

      count.textContent = `${lessons.length} note${lessons.length !== 1 ? 's' : ''}`;

      content.innerHTML = lessons.map(lesson => {
        const typeClass = lesson.type === 'success' ? 'success' :
                          lesson.type === 'warning' ? 'warning' :
                          lesson.type === 'error' ? 'error' : '';

        const timeAgo = getTimeAgo(new Date(lesson.timestamp));

        return `
          <div class="lesson-item ${typeClass}">
            <div class="lesson-task">
              <span>${lesson.taskId || 'General'}</span>
              <span>${timeAgo}</span>
            </div>
            <div class="lesson-text">${lesson.text || lesson.note}</div>
            ${lesson.tags ? `
              <div class="lesson-tags">
                ${lesson.tags.map(t => `<span class="lesson-tag">${t}</span>`).join('')}
              </div>
            ` : ''}
          </div>
        `;
      }).join('');
    }

    function getTimeAgo(date) {
      const seconds = Math.floor((new Date() - date) / 1000);
      if (seconds < 60) return 'just now';
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    // ===== UI HELPERS =====
    function toggleUsageDropdown() {
      const dropdown = document.getElementById('usageDropdown');
      const button = dropdown.previousElementSibling;
      const isOpen = dropdown.classList.toggle('open');
      button.setAttribute('aria-expanded', isOpen);
    }

    // ===== TAB SWITCHING (v4) =====
    function switchTab(name) {
      document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.view-pane').forEach(p => p.classList.remove('active'));
      const tab = document.querySelector(`.view-tab[data-tab="${name}"]`);
      const pane = document.getElementById(`pane-${name}`);
      if (tab) tab.classList.add('active');
      if (pane) pane.classList.add('active');
    }

    // ==========================================
    // Session Launcher Modal Functions
    // ==========================================

    let launcherSelectedPath = null;

    function openNewSessionModal() {
      const modal = document.getElementById('sessionLauncherModal');
      if (modal) {
        modal.classList.add('open');
        launcherSelectedPath = null;
        const customInput = document.getElementById('customProjectPath');
        if (customInput) {
          customInput.value = '';
          setTimeout(() => customInput.focus(), 100);
        }
        fetchProjects();
      }
    }

    function closeNewSessionModal() {
      const modal = document.getElementById('sessionLauncherModal');
      if (modal) modal.classList.remove('open');
      launcherSelectedPath = null;
    }

    async function fetchProjects() {
      const container = document.getElementById('projectList');
      if (!container) return;
      container.innerHTML = '<div class="loading-projects">Loading projects...</div>';

      try {
        const res = await fetch('/api/projects');
        const data = await res.json();
        renderProjectList(data.projects || []);
      } catch (err) {
        console.error('Failed to fetch projects:', err);
        container.innerHTML = '<div class="no-projects">Enter a custom path below.</div>';
      }
    }

    function renderProjectList(projects) {
      const container = document.getElementById('projectList');
      if (!container) return;

      if (!projects || projects.length === 0) {
        container.innerHTML = '<div class="no-projects">No recent projects. Enter a custom path below.</div>';
        return;
      }

      container.innerHTML = projects.map(p => {
        const escapedPath = (p.path || '').replace(/\\/g, '\\\\').replace(/'/g, "\\'");
        return `
          <div class="project-option" onclick="selectLaunchProject('${escapedPath}', this)">
            <span class="project-name">${escapeHtml(p.name || 'Unknown')}</span>
            <span class="project-path">${escapeHtml(p.path || '')}</span>
          </div>
        `;
      }).join('');
    }

    function selectLaunchProject(path, element) {
      launcherSelectedPath = path;
      document.querySelectorAll('.project-option').forEach(el => el.classList.remove('selected'));
      if (element) element.classList.add('selected');
      const customInput = document.getElementById('customProjectPath');
      if (customInput) customInput.value = path;
    }

    async function launchSession() {
      const customInput = document.getElementById('customProjectPath');
      const projectPath = (customInput && customInput.value.trim()) || launcherSelectedPath;

      if (!projectPath) {
        showToast('error', 'Error', 'Please select or enter a project path');
        return;
      }

      try {
        const res = await fetch('/api/sessions/launch', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ projectPath })
        });
        const data = await res.json();

        if (data.success) {
          showToast('success', 'Launched', 'New Claude session started');
          closeNewSessionModal();
        } else {
          showToast('error', 'Failed', data.message || 'Unknown error');
        }
      } catch (err) {
        console.error('Failed to launch session:', err);
        showToast('error', 'Error', err.message || 'Failed to launch session');
      }
    }

    // ==========================================
    // Tab Pane Update Functions (v4)
    // ==========================================

    function updateOverviewPane(session) {
      console.log('[Dashboard] updateOverviewPane called');
      const pane = document.getElementById('pane-overview');
      console.log('[Dashboard] pane-overview element:', pane);
      if (!pane) return;

      if (!session) {
        pane.innerHTML = '<div class="section-header">Select a session</div><p style="color: var(--text-muted)">Click a session in the left panel to view details.</p>';
        return;
      }

      const ctx = session.contextPercent || session.context || 0;
      const msgs = session.messages || 0;
      // Calculate tokens from percentage to match statusline (avoids systemOverhead inflation)
      // Claude context window is ~200k, but effective is ~155k after reserved space
      const effectiveContextWindow = 155000;
      const tokens = Math.round((ctx / 100) * effectiveContextWindow);
      const task = session.currentTask || {};

      pane.innerHTML = `
        <div class="section-header">${escapeHtml(session.name || session.id || 'Session')}</div>
        <div class="metrics-grid">
          <div class="metric-card">
            <div class="metric-card-label">Context</div>
            <div class="metric-card-value">${ctx.toFixed(1)}%</div>
            <div class="metric-card-bar"><div class="metric-card-bar-fill" style="width:${ctx}%;background:var(--color-${ctx > 85 ? 'danger' : ctx > 70 ? 'warning' : 'success'})"></div></div>
          </div>
          <div class="metric-card">
            <div class="metric-card-label">Messages</div>
            <div class="metric-card-value">${msgs}</div>
          </div>
          <div class="metric-card">
            <div class="metric-card-label">Tokens</div>
            <div class="metric-card-value">${(tokens/1000).toFixed(1)}k</div>
          </div>
          <div class="metric-card">
            <div class="metric-card-label">Phase</div>
            <div class="metric-card-value" style="font-size:14px">${escapeHtml(session.phase || task.phase || 'Idle')}</div>
          </div>
        </div>
        ${task.id ? `
          <div class="section-header">Current Task</div>
          <table class="data-table">
            <tr><th>Task</th><th>Status</th></tr>
            <tr><td>${escapeHtml(task.title || task.id)}</td><td><span class="status-badge in-progress">Active</span></td></tr>
          </table>
        ` : ''}
      `;
    }

    function updateTasksPane(session) {
      const pane = document.getElementById('pane-tasks');
      if (!pane) return;

      if (!session) {
        pane.innerHTML = '<div class="section-header">Tasks</div><p style="color: var(--text-muted)">Select a session to view tasks.</p>';
        return;
      }

      const task = session.currentTask || {};
      const queue = session.taskQueue || [];

      pane.innerHTML = `
        <div class="section-header">Active</div>
        <table class="data-table">
          <tr><th>Task</th><th>Status</th></tr>
          ${task.id ? `<tr><td>${escapeHtml(task.title || task.id)}</td><td><span class="status-badge in-progress">Active</span></td></tr>` : '<tr><td colspan="2" style="color:var(--text-muted)">No active task</td></tr>'}
        </table>
        <div class="section-header">Queue (${queue.length})</div>
        <table class="data-table">
          <tr><th>Task</th><th>Priority</th></tr>
          ${queue.slice(0, 5).map(t => `<tr><td>${escapeHtml(t.title || t.id)}</td><td>${t.priority || 'normal'}</td></tr>`).join('') || '<tr><td colspan="2" style="color:var(--text-muted)">No tasks in queue</td></tr>'}
        </table>
      `;
    }

    function updateHierarchyPane(session) {
      const pane = document.getElementById('pane-hierarchy');
      if (!pane) return;

      if (!session) {
        pane.innerHTML = '<div class="section-header">Hierarchy</div><p style="color: var(--text-muted)">Select a session to view hierarchy.</p>';
        return;
      }

      const children = session.childAgents || session.children || [];

      // Build user-friendly session label
      function getSessionLabel(s, isRoot = false) {
        // Prefer: name > project name > "Session #id"
        if (s.name && !s.name.match(/^[0-9a-f-]{8,}$/i)) return s.name;
        if (s.project && s.project !== 'unknown') return s.project;
        const type = (s.sessionType || s.type || 'cli').toUpperCase();
        return isRoot ? `${type} Session` : `Sub-agent #${s.id}`;
      }

      // Get status badge
      function getStatusBadge(s) {
        const status = s.status || 'active';
        const colors = { active: '#4ade80', idle: '#94a3b8', ended: '#64748b', error: '#f87171' };
        return `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${colors[status] || colors.active};margin-right:6px;" title="${status}"></span>`;
      }

      const sessionLabel = getSessionLabel(session, true);
      const sessionType = (session.sessionType || session.type || 'cli').toUpperCase();

      pane.innerHTML = `
        <div class="section-header">Agent Hierarchy</div>
        <div class="hierarchy-tree">
          <div class="hierarchy-node">
            <div class="hierarchy-row" style="display:flex;align-items:center;gap:8px;">
              ${getStatusBadge(session)}
              <span style="font-weight:500;">${escapeHtml(sessionLabel)}</span>
              <span class="session-type ${session.sessionType || 'cli'}" style="font-size:10px;padding:2px 6px;">${sessionType}</span>
              ${session.phase ? `<span style="color:var(--text-muted);font-size:11px;"> ${session.phase}</span>` : ''}
            </div>
            ${children.length > 0 ? `
              <div class="hierarchy-children" style="margin-left:20px;margin-top:8px;border-left:2px solid var(--border-color);padding-left:12px;">
                ${children.map(c => {
                  const subChildren = c.childAgents || c.children || [];
                  return `
                    <div class="hierarchy-node" style="margin:6px 0;">
                      <div class="hierarchy-row" style="display:flex;align-items:center;gap:8px;">
                        ${getStatusBadge(c)}
                        <span>${escapeHtml(getSessionLabel(c, false))}</span>
                        <span class="session-type auto" style="font-size:10px;padding:2px 6px;">AUTO</span>
                      </div>
                      ${subChildren.length === 0 ? `
                        <div style="margin-left:20px;margin-top:4px;color:var(--text-muted);font-size:11px;">
                          No sub-agents
                        </div>
                      ` : ''}
                    </div>
                  `;
                }).join('')}
              </div>
            ` : `
              <div style="margin-left:20px;margin-top:8px;color:var(--text-muted);font-size:12px;">
                No agents or sub-agents delegated
              </div>
            `}
          </div>
        </div>
      `;
    }

    function updateDetailsPane(session) {
      const pane = document.getElementById('pane-details');
      if (!pane) return;

      if (!session) {
        pane.innerHTML = '<div class="section-header">Details</div><p style="color: var(--text-muted)">Select a session to view details.</p>';
        return;
      }

      const shortId = getShortSessionId(session.id);
      const rows = [
        ['Type', session.type || 'CLI'],
        ['Project', session.project || '-'],
        ['Phase', session.phase || '-'],
        ['Model', session.model || 'claude-sonnet-4'],
        ['Messages', session.messages || 0],
        ['Input Tokens', (session.inputTokens || 0).toLocaleString()],
        ['Output Tokens', (session.outputTokens || 0).toLocaleString()],
        ['Context', `${(session.contextPercent || 0).toFixed(1)}%`]
      ];

      pane.innerHTML = `
        <div class="section-header">Session Details</div>
        <table class="data-table">
          <tr><td style="width:120px;color:var(--text-muted)">Session</td><td><strong>${escapeHtml(shortId)}</strong> <span style="color:var(--text-muted);font-size:11px">${escapeHtml(session.id)}</span></td></tr>
          ${rows.map(([k, v]) => `<tr><td style="width:120px;color:var(--text-muted)">${k}</td><td>${escapeHtml(String(v))}</td></tr>`).join('')}
        </table>
      `;
    }

    function updateLogsPane(session) {
      const pane = document.getElementById('pane-logs');
      if (!pane) return;

      if (!session) {
        pane.innerHTML = '<div class="section-header">Logs</div><p style="color: var(--text-muted)">Select a session to view logs.</p>';
        return;
      }

      // CLI sessions don't have logs in the dashboard
      if (!session.registryId) {
        pane.innerHTML = `
          <div class="section-header">Activity Log</div>
          <p style="color: var(--text-muted); padding: 12px;">
            CLI sessions run independently and log to their terminal.<br><br>
            Logs are only available for autonomous orchestrator sessions.
          </p>
        `;
        return;
      }

      const logs = session.logs || session.activityLog || [];

      pane.innerHTML = `
        <div class="section-header">Activity Log</div>
        <table class="data-table">
          <tr><th style="width:80px">Time</th><th style="width:50px">Level</th><th>Message</th></tr>
          ${logs.length > 0 ? logs.slice(0, 20).map(l => `
            <tr>
              <td style="color:var(--text-muted)">${l.timestamp ? new Date(l.timestamp).toLocaleTimeString() : '-'}</td>
              <td style="color:var(--color-${l.level === 'ERROR' ? 'danger' : l.level === 'WARN' ? 'warning' : 'info'})">${l.level || 'INFO'}</td>
              <td>${escapeHtml(l.message || '')}</td>
            </tr>
          `).join('') : '<tr><td colspan="3" style="color:var(--text-muted)">No log entries</td></tr>'}
        </table>
      `;
    }

    function updateAllTabPanes(session) {
      console.log('[Dashboard] updateAllTabPanes called with session:', session?.id, session);
      updateOverviewPane(session);
      updateTasksPane(session);
      updateHierarchyPane(session);
      updateDetailsPane(session);
      updateLogsPane(session);
    }

    function toggleSettings() {
      const modal = document.getElementById('settingsModal');
      modal.classList.toggle('open');
    }

    function toggleSetting(el) {
      el.classList.toggle('active');
      const setting = el.dataset.setting;
      settings[setting] = el.classList.contains('active');
      localStorage.setItem('dashboardSettings', JSON.stringify(settings));

      // Re-render affected components
      updateSessionList();
      if (selectedSessionId) {
        updateDetailPanel();
      }
    }

    function loadSettingsUI() {
      document.querySelectorAll('.toggle[data-setting]').forEach(el => {
        const setting = el.dataset.setting;
        if (settings[setting]) {
          el.classList.add('active');
        } else {
          el.classList.remove('active');
        }
      });
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.usage-badge') && !e.target.closest('.usage-dropdown')) {
        const dropdown = document.getElementById('usageDropdown');
        if (dropdown) dropdown.classList.remove('open');
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

      const sessionList = sessions;
      const currentIndex = sessionList.findIndex(s => s.id === selectedSessionId);

      switch (e.key) {
        // Session navigation (j/k or arrow keys)
        case 'j':
        case 'ArrowDown':
          e.preventDefault();
          if (currentIndex < sessionList.length - 1) {
            selectSession(sessionList[currentIndex + 1].id);
          } else if (sessionList.length > 0) {
            selectSession(sessionList[0].id);
          }
          break;
        case 'k':
        case 'ArrowUp':
          e.preventDefault();
          if (currentIndex > 0) {
            selectSession(sessionList[currentIndex - 1].id);
          } else if (sessionList.length > 0) {
            selectSession(sessionList[sessionList.length - 1].id);
          }
          break;

        // Tab switching (1-5) - v4
        case '1': case '2': case '3': case '4': case '5':
          const tabs = ['overview', 'tasks', 'hierarchy', 'details', 'logs'];
          const tabIndex = parseInt(e.key) - 1;
          if (tabs[tabIndex]) {
            e.preventDefault();
            switchTab(tabs[tabIndex]);
          }
          break;

        // Toggle actions
        case 'a': // Toggle Agent Lineage panel
        case 'A':
          toggleFleetLineage();
          break;
        case 'l': // Toggle Logs (expand detail panel)
        case 'L':
          if (selectedSessionId) {
            const logsSection = document.querySelector('.log-list');
            if (logsSection) {
              logsSection.scrollIntoView({ behavior: 'smooth' });
            }
          }
          break;
        case 'm': // Mute/Unmute alerts
        case 'M':
          muteAlertSound();
          showToast('info', 'Alerts', FleetState.alertMuted ? 'Alerts muted' : 'Alerts unmuted', 2000);
          break;

        // New session launcher
        case 'n':
          e.preventDefault();
          openNewSessionModal();
          break;

        // Session controls
        case 'p': // Pause/Resume
          if (selectedSessionId) togglePause(selectedSessionId);
          break;
        case 's': // Skip task
          if (selectedSessionId) skipTask(selectedSessionId);
          break;

        // Escape
        case 'Escape':
          // Close lineage panel if open
          if (FleetLineageState.visible) {
            toggleFleetLineage();
          } else {
            // Deselect session
            selectedSessionId = null;
            updateSessionList();
            document.getElementById('detailEmpty').style.display = 'flex';
            document.getElementById('detailContent').style.display = 'none';
          }
          break;

        // Help
        case '?':
          alert('Keyboard Shortcuts:\n\n' +
            '/ or j/k - Navigate sessions\n' +
            '1-9 - Jump to project card\n' +
            'a - Toggle Agent Lineage\n' +
            'l - Jump to Logs\n' +
            'm - Mute/Unmute alerts\n' +
            'p - Pause/Resume session\n' +
            's - Skip current task\n' +
            'Esc - Close panel or deselect\n' +
            '? - Show this help');
          break;
      }
    });

    // ===== HIERARCHY VISUALIZATION =====
    const HierarchyTreeState = {
      rootNode: null,
      nodeMap: new Map(),
      selectedNodeId: null,
      expandedNodeIds: new Set(),
      currentSessionId: null,

      reset() {
        this.rootNode = null;
        this.nodeMap.clear();
        this.selectedNodeId = null;
        this.expandedNodeIds.clear();
      },

      registerNode(node) {
        this.nodeMap.set(node.id, node);
      },

      getNode(nodeId) {
        return this.nodeMap.get(nodeId);
      }
    };

    async function loadHierarchy(sessionId) {
      if (!sessionId) return;
      HierarchyTreeState.currentSessionId = sessionId;
      HierarchyTreeState.reset();

      const container = document.getElementById('hierarchyTreeContainer');
      if (!container) return;

      container.innerHTML = '<div class="hierarchy-empty"><div class="hierarchy-empty-icon">Loading...</div></div>';

      try {
        const response = await fetch(`/api/sessions/${encodeURIComponent(sessionId)}/hierarchy`);

        if (!response.ok) {
          if (response.status === 404) {
            container.innerHTML = '<div class="hierarchy-empty"><div class="hierarchy-empty-icon">No delegation data</div></div>';
            return;
          }
          throw new Error(`API error: ${response.status}`);
        }

        const hierarchyData = await response.json();
        const rootNode = transformHierarchyData(hierarchyData, null, 0);

        HierarchyTreeState.rootNode = rootNode;
        HierarchyTreeState.expandedNodeIds.add(rootNode.id);

        renderHierarchyTree(container);
      } catch (error) {
        console.error('Failed to load hierarchy:', error);
        container.innerHTML = `<div class="hierarchy-empty"><div class="hierarchy-empty-icon">Error loading hierarchy</div></div>`;
      }
    }

    function transformHierarchyData(apiNode, parentId, depth) {
      const node = {
        id: apiNode.id || apiNode.agentId || `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        name: apiNode.name || apiNode.persona || apiNode.agentId || 'Unknown Agent',
        type: apiNode.type || (depth === 0 ? 'root' : 'agent'),
        status: normalizeHierarchyStatus(apiNode.status),
        children: [],
        parentId: parentId,
        depth: depth,
        metrics: {
          tokensUsed: apiNode.metrics?.tokensUsed || 0,
          qualityScore: apiNode.metrics?.qualityScore || 0,
          durationMs: apiNode.metrics?.durationMs || 0
        }
      };

      HierarchyTreeState.registerNode(node);

      const childNodes = apiNode.children || apiNode.delegates || apiNode.subAgents || [];
      node.children = childNodes.map(child => transformHierarchyData(child, node.id, depth + 1));

      return node;
    }

    function normalizeHierarchyStatus(status) {
      const statusMap = {
        'running': 'active', 'in_progress': 'active',
        'success': 'completed', 'done': 'completed',
        'error': 'failed', 'waiting': 'pending', 'queued': 'pending'
      };
      return statusMap[status] || status || 'idle';
    }

    function renderHierarchyTree(container) {
      if (!HierarchyTreeState.rootNode) {
        container.innerHTML = '<div class="hierarchy-empty"><div class="hierarchy-empty-icon">No hierarchy data</div></div>';
        return;
      }

      const treeHtml = renderHierarchyNode(HierarchyTreeState.rootNode);
      container.innerHTML = `<div class="hierarchy-tree">${treeHtml}</div>`;
      attachHierarchyEvents(container);
    }

    function renderHierarchyNode(node) {
      const hasChildren = node.children && node.children.length > 0;
      const isExpanded = HierarchyTreeState.expandedNodeIds.has(node.id);
      const isSelected = HierarchyTreeState.selectedNodeId === node.id;

      const nodeClasses = [
        'hierarchy-tree__node',
        `hierarchy-tree__node--${node.type}`,
        `hierarchy-tree__node--${node.status}`,
        hasChildren ? 'hierarchy-tree__node--has-children' : '',
        isExpanded ? 'hierarchy-tree__node--expanded' : '',
        isSelected ? 'hierarchy-tree__node--selected' : ''
      ].filter(Boolean).join(' ');

      const icons = { root: '&#x1F3E0;', session: '&#x1F4CB;', agent: '&#x1F916;' };
      const icon = icons[node.type] || '&#x1F4C4;';

      return `
        <div class="${nodeClasses}" data-node-id="${escapeHtmlAttr(node.id)}" data-depth="${node.depth}">
          <div class="hierarchy-tree__node-row">
            ${hasChildren ? `
              <button class="hierarchy-tree__toggle" data-action="toggle" data-node-id="${escapeHtmlAttr(node.id)}">
                ${isExpanded ? '&#9660;' : '&#9654;'}
              </button>
            ` : '<span class="hierarchy-tree__toggle-placeholder"></span>'}
            <span class="hierarchy-tree__status-dot hierarchy-tree__status-dot--${node.status}"></span>
            <span class="hierarchy-tree__icon">${icon}</span>
            <span class="hierarchy-tree__name" data-action="select" data-node-id="${escapeHtmlAttr(node.id)}">${escapeHtmlContent(node.name)}</span>
            ${node.metrics.tokensUsed > 0 ? `<span class="hierarchy-tree__metric" title="Tokens">${formatTokens(node.metrics.tokensUsed)}</span>` : ''}
            ${hasChildren ? `<span class="hierarchy-tree__badge">${node.children.length}</span>` : ''}
          </div>
          ${hasChildren ? `
            <div class="hierarchy-tree__children" style="display: ${isExpanded ? 'block' : 'none'}">
              ${node.children.map(child => renderHierarchyNode(child)).join('')}
            </div>
          ` : ''}
        </div>
      `;
    }

    function escapeHtml(str) {
      if (!str) return '';
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function escapeHtmlAttr(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function escapeHtmlContent(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function formatTokens(num) {
      if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
      if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
      return num.toString();
    }

    function attachHierarchyEvents(container) {
      container.addEventListener('click', (e) => {
        const target = e.target.closest('[data-action]');
        if (!target) return;

        const action = target.dataset.action;
        const nodeId = target.dataset.nodeId;
        if (!nodeId) return;

        if (action === 'toggle') {
          toggleHierarchyNode(nodeId);
        } else if (action === 'select') {
          selectHierarchyNode(nodeId);
        }
      });
    }

    function toggleHierarchyNode(nodeId) {
      const node = HierarchyTreeState.getNode(nodeId);
      if (!node || !node.children || node.children.length === 0) return;

      const isExpanded = HierarchyTreeState.expandedNodeIds.has(nodeId);
      if (isExpanded) {
        HierarchyTreeState.expandedNodeIds.delete(nodeId);
      } else {
        HierarchyTreeState.expandedNodeIds.add(nodeId);
      }

      const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
      if (nodeEl) {
        nodeEl.classList.toggle('hierarchy-tree__node--expanded', !isExpanded);
        const toggleIcon = nodeEl.querySelector('.hierarchy-tree__toggle');
        if (toggleIcon) toggleIcon.innerHTML = !isExpanded ? '&#9660;' : '&#9654;';
        const childrenEl = nodeEl.querySelector(':scope > .hierarchy-tree__children');
        if (childrenEl) childrenEl.style.display = !isExpanded ? 'block' : 'none';
      }
    }

    function selectHierarchyNode(nodeId) {
      const previousId = HierarchyTreeState.selectedNodeId;
      HierarchyTreeState.selectedNodeId = nodeId;

      if (previousId) {
        const prevEl = document.querySelector(`[data-node-id="${previousId}"]`);
        if (prevEl) prevEl.classList.remove('hierarchy-tree__node--selected');
      }

      const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
      if (nodeEl) nodeEl.classList.add('hierarchy-tree__node--selected');
    }

    function expandAllHierarchy() {
      HierarchyTreeState.nodeMap.forEach((node, id) => {
        if (node.children && node.children.length > 0 && !HierarchyTreeState.expandedNodeIds.has(id)) {
          toggleHierarchyNode(id);
        }
      });
    }

    function collapseAllHierarchy() {
      HierarchyTreeState.nodeMap.forEach((node, id) => {
        if (node.depth > 0 && HierarchyTreeState.expandedNodeIds.has(id)) {
          toggleHierarchyNode(id);
        }
      });
    }

    function refreshHierarchy(sessionId) {
      loadHierarchy(sessionId || HierarchyTreeState.currentSessionId);
    }

    // =====================================================================
    // FLEET MANAGEMENT FUNCTIONS (NEW)
    // =====================================================================

    // Fleet state
    const FleetState = {
      overview: null,
      agentPool: null,
      alerts: [],
      ws: null,
      alertMuted: false,
      lastUpdate: null
    };

    // Fetch fleet overview data
    async function fetchFleetOverview() {
      try {
        const res = await fetch('/api/overview');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        FleetState.overview = await res.json();
        FleetState.lastUpdate = new Date();
        updateFleetHeader();
        updateAlertBanner();
        updateProjectCards();
        return FleetState.overview;
      } catch (err) {
        console.error('[FLEET] Failed to fetch overview:', err);
        return null;
      }
    }

    // Update fleet header with countdown timers
    function updateFleetHeader() {
      const overview = FleetState.overview;
      if (!overview) return;

      const { global, account, agentPool, alertCount } = overview;

      // Active Session Context (from real globalTracker data)
      const activeProject = overview.projects?.find(p =>
        p.activeSessionCount > 0 || p.sessions?.some(s => s.status === 'active')
      );
      const activeSession = activeProject?.sessions?.find(s => s.status === 'active');

      const contextPercent = activeSession?.contextPercent || 0;
      const sessionCost = activeSession?.cost || 0;
      const remaining = 100 - contextPercent;

      const contextEl = document.getElementById('fleetContextPercent');
      const contextFill = document.getElementById('fleetContextFill');
      const costEl = document.getElementById('fleetSessionCost');

      if (contextEl) {
        contextEl.textContent = contextPercent.toFixed(1) + '%';
        contextEl.className = 'countdown-time' + (contextPercent > 85 ? ' critical' : contextPercent > 70 ? ' warning' : '');
      }

      if (contextFill) {
        contextFill.style.width = contextPercent + '%';
        contextFill.className = 'countdown-bar-fill' + (contextPercent > 85 ? ' critical' : contextPercent > 70 ? ' warning' : '');
      }

      if (costEl) {
        costEl.textContent = activeSession
          ? `$${sessionCost.toFixed(2)} this session`
          : 'No active session';
      }

      // ===== V4 TOP BAR METRICS =====
      const metricProjects = document.getElementById('metricProjects');
      const metricSessions = document.getElementById('metricSessions');
      const metricTasks = document.getElementById('metricTasks');
      const metricAgents = document.getElementById('metricAgents');
      const metricSubAgents = document.getElementById('metricSubAgents');
      const sessionCount = document.getElementById('sessionCount');

      if (metricProjects) metricProjects.textContent = global.activeProjectCount || 0;
      if (metricSessions) metricSessions.textContent = global.activeSessionCount || 0;
      if (metricTasks) metricTasks.textContent = `${global.completedTasks || 0}/${global.totalTasks || 0}`;
      if (metricAgents) metricAgents.textContent = agentPool?.activeAgents || 0;
      if (metricSubAgents) metricSubAgents.textContent = `/ ${agentPool?.subAgents || 0} sub`;
      if (sessionCount) sessionCount.textContent = global.activeSessionCount || 0;

      // Legacy fleet header elements (for backward compatibility)
      const activeSessions = document.getElementById('fleetActiveSessions');
      const projectCountEl = document.getElementById('fleetProjectCount');
      const alertCountEl = document.getElementById('fleetAlertCount');

      if (activeSessions) activeSessions.textContent = global.activeSessionCount || 0;
      if (projectCountEl) projectCountEl.textContent = global.activeProjectCount || 0;

      if (alertCountEl) {
        const totalAlerts = (global.alertCount?.critical || 0) + (global.alertCount?.warning || 0);
        alertCountEl.textContent = totalAlerts;
        alertCountEl.className = 'fleet-stat-value' + (global.alertCount?.critical > 0 ? ' critical' : totalAlerts > 0 ? ' warning' : '');
      }

      // Account Totals (legacy)
      const totalCost = document.getElementById('fleetTotalCost');
      const totalSessions = document.getElementById('fleetTotalSessions');

      if (totalCost) totalCost.textContent = '$' + (account?.totalCost || 0).toFixed(2);
      if (totalSessions) totalSessions.textContent = account?.sessionCount || 0;
    }

    // Update alert banner for critical alerts
    function updateAlertBanner() {
      const overview = FleetState.overview;
      if (!overview || !overview.alerts) return;

      const criticalAlerts = overview.alerts.filter(a => a.level === 'critical');
      const banner = document.getElementById('alertBanner');

      if (criticalAlerts.length > 0 && !FleetState.alertMuted) {
        const alert = criticalAlerts[0];
        document.getElementById('alertBannerText').textContent = alert.message;
        document.getElementById('alertBannerIcon').textContent = alert.type === 'token_exhaustion' ? '' : '';
        banner.classList.add('visible');
        banner.classList.remove('warning');

        // Store current alert for action handling
        FleetState.currentAlert = alert;

        // Play alert sound (if not muted)
        playAlertSound('critical');
      } else {
        banner.classList.remove('visible');
      }
    }

    // Play alert sound
    function playAlertSound(level) {
      if (FleetState.alertMuted) return;

      try {
        // Create a simple beep using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = level === 'critical' ? 880 : 440;
        oscillator.type = 'sine';
        gainNode.gain.value = 0.3;

        oscillator.start();
        setTimeout(() => {
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
          setTimeout(() => oscillator.stop(), 500);
        }, 100);
      } catch (e) {
        console.log('[FLEET] Audio not available');
      }
    }

    // Handle alert banner action
    function handleAlertAction(action) {
      const alert = FleetState.currentAlert;
      if (!alert) return;

      if (action === 'view' && alert.sessionId) {
        // Select the session in the session list
        const sessionEl = document.querySelector(`[data-session-id="${alert.sessionId}"]`);
        if (sessionEl) sessionEl.click();
      }
    }

    // Dismiss alert banner
    function dismissAlertBanner() {
      const banner = document.getElementById('alertBanner');
      banner.classList.remove('visible');
    }

    // Mute/unmute alert sounds
    function muteAlertSound() {
      FleetState.alertMuted = !FleetState.alertMuted;
      const btn = document.getElementById('alertMuteBtn');
      if (btn) btn.textContent = FleetState.alertMuted ? ' Unmute' : ' Mute';
    }

    // Toast notification system
    function showToast(type, title, message, duration = 5000) {
      let container = document.getElementById('toastContainer');
      if (!container) {
        container = document.createElement('div');
        container.id = 'toastContainer';
        container.className = 'toast-container';
        document.body.appendChild(container);
      }

      const icons = { success: '', warning: '', error: '', info: '' };

      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <span class="toast-icon">${icons[type] || ''}</span>
        <div class="toast-content">
          <div class="toast-title">${title}</div>
          <div class="toast-message">${message}</div>
        </div>
        <button class="toast-close" onclick="this.parentElement.remove()"></button>
      `;

      container.appendChild(toast);

      // Auto-dismiss
      if (duration > 0) {
        setTimeout(() => {
          if (toast.parentElement) {
            toast.style.animation = 'slideIn 0.3s ease reverse';
            setTimeout(() => toast.remove(), 300);
          }
        }, duration);
      }

      return toast;
    }

    // Initialize WebSocket for real-time fleet events
    function initFleetWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws/fleet`;

      try {
        FleetState.ws = new WebSocket(wsUrl);

        FleetState.ws.onopen = () => {
          console.log('[FLEET WS] Connected');
        };

        FleetState.ws.onmessage = (event) => {
          try {
            const msg = JSON.parse(event.data);
            handleFleetEvent(msg);
          } catch (e) {
            console.error('[FLEET WS] Parse error:', e);
          }
        };

        FleetState.ws.onclose = () => {
          console.log('[FLEET WS] Disconnected, reconnecting in 5s...');
          setTimeout(initFleetWebSocket, 5000);
        };

        FleetState.ws.onerror = (err) => {
          console.error('[FLEET WS] Error:', err);
        };
      } catch (e) {
        console.error('[FLEET WS] Failed to connect:', e);
      }
    }

    // Handle fleet WebSocket events
    function handleFleetEvent(msg) {
      switch (msg.type) {
        case 'init':
          console.log('[FLEET WS] Init:', msg);
          break;

        case 'session:started':
          showToast('success', 'Session Started', `Session ${msg.sessionId} started for ${msg.project}`);
          fetchFleetOverview();
          break;

        case 'session:completed':
          showToast('info', 'Session Completed', `Session ${msg.sessionId} completed`);
          fetchFleetOverview();
          break;

        case 'delegation:started':
          showToast('info', 'Delegation Started', `Task delegated: ${msg.taskId}`);
          break;

        case 'delegation:completed':
          showToast('success', 'Delegation Completed', `Delegation finished in ${Math.round(msg.duration / 1000)}s`);
          break;

        case 'delegation:failed':
          showToast('error', 'Delegation Failed', msg.error || 'Unknown error');
          break;

        case 'task:completed':
          showToast('success', 'Task Completed', `${msg.taskId} (score: ${msg.score})`);
          break;

        case 'task:claimed':
          showToast('info', 'Task Claimed', `${msg.taskId} claimed by session ${msg.sessionId}`);
          break;

        case 'alert:critical':
          fetchFleetOverview(); // Will trigger banner update
          break;

        case 'alert:warning':
          showToast('warning', 'Warning', msg.message);
          break;

        default:
          console.log('[FLEET WS] Unknown event:', msg.type);
      }
    }

    // =====================================================================
    // PROJECT CARDS RENDERING
    // =====================================================================

    // Update project cards from FleetState.overview
    function updateProjectCards() {
      const container = document.getElementById('projectCards');
      if (!container) return;

      const overview = FleetState.overview;
      if (!overview || !overview.projects || overview.projects.length === 0) {
        container.innerHTML = '';  // Hide completely when no projects
        return;
      }

      // Filter to only show projects with recently active sessions (same 10-min threshold as session list)
      const tenMinsAgo = Date.now() - (10 * 60 * 1000);
      const activeProjects = overview.projects.filter(p => {
        // Check if any session for this project has recent activity in our local sessions array
        const projectSessions = sessions.filter(s => s.project === p.name);
        return projectSessions.some(s => (s.lastUpdate || 0) > tenMinsAgo);
      });

      if (activeProjects.length === 0) {
        container.innerHTML = '';  // Hide completely when no active projects
        return;
      }

      container.innerHTML = activeProjects.map((project, index) => {
        // Convert health string to numeric score (healthy=100, warning=60, critical=20)
        const healthScore = project.health === 'healthy' ? 100 :
                           project.health === 'warning' ? 60 :
                           project.health === 'critical' ? 20 : 0;
        const healthDots = renderHealthDots(healthScore);
        const activeTasks = project.activeTasks || [];
        const sessionCount = project.sessions?.length || 0;
        const projectId = project.name; // API returns name, not id

        return `
          <div class="project-card" role="listitem" data-project-index="${index + 1}" tabindex="0"
               onclick="selectProject('${projectId}')"
               onkeydown="if(event.key==='Enter'||event.key===' ')selectProject('${projectId}')">
            <div class="project-card-header">
              <div class="project-card-title">
                <span>${project.name || project.id}</span>
                ${healthDots}
              </div>
              <span class="project-task-progress">${sessionCount} session${sessionCount !== 1 ? 's' : ''}</span>
            </div>
            <div class="project-card-body">
              <div class="project-task-list">
                ${activeTasks.length > 0 ? activeTasks.slice(0, 3).map(task => `
                  <div class="project-task-item">
                    <div class="project-task-status ${task.status || 'pending'}"></div>
                    <span class="project-task-name">${task.title || task.id}</span>
                    ${task.progress ? `<span class="project-task-progress">${task.progress}%</span>` : ''}
                  </div>
                `).join('') : '<div class="project-task-item"><span class="project-task-name" style="color: var(--text-muted)">No active tasks</span></div>'}
                ${activeTasks.length > 3 ? `<div class="project-task-item"><span class="project-task-name" style="color: var(--text-muted)">+${activeTasks.length - 3} more...</span></div>` : ''}
              </div>
            </div>
            <div class="project-card-footer">
              <span>Cost: $${(project.metrics?.totalCost || project.cost || 0).toFixed(2)}</span>
              <button class="project-expand-btn" onclick="event.stopPropagation(); expandProject('${projectId}')">
                Details 
              </button>
            </div>
          </div>
        `;
      }).join('');
    }

    // Render health dots (0-5 filled based on score)
    function renderHealthDots(score) {
      const filled = Math.round((score / 100) * 5);
      let dots = '<div class="project-health-dots">';
      for (let i = 0; i < 5; i++) {
        dots += `<div class="project-health-dot ${i < filled ? '' : 'empty'}"></div>`;
      }
      dots += '</div>';
      return dots;
    }

    // Select a project (jump to its sessions in session list)
    function selectProject(projectId) {
      // Find first session of this project
      const session = sessions.find(s => s.project === projectId);
      if (session) {
        selectSession(session.id);
        // Scroll session into view
        const sessionEl = document.querySelector(`[data-session-id="${session.id}"]`);
        if (sessionEl) sessionEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    // Expand project details (show all sessions for project)
    function expandProject(projectId) {
      // Filter to show only this project's sessions
      const projectSessions = sessions.filter(s => s.project === projectId);
      if (projectSessions.length > 0) {
        // Expand the project group if collapsed
        const groupEl = document.querySelector(`.session-group[data-project="${projectId}"]`);
        if (groupEl && groupEl.classList.contains('collapsed')) {
          groupEl.classList.remove('collapsed');
        }
        // Select first session
        selectSession(projectSessions[0].id);
      }
    }

    // =====================================================================
    // FLEET LINEAGE FUNCTIONS
    // =====================================================================

    // Fleet lineage state
    const FleetLineageState = {
      visible: false,
      hierarchy: null,
      expandedNodes: new Set()
    };

    // Toggle fleet lineage panel visibility
    function toggleFleetLineage() {
      const panel = document.getElementById('fleetLineageSection');
      const btn = document.getElementById('viewLineageBtn');

      FleetLineageState.visible = !FleetLineageState.visible;

      if (FleetLineageState.visible) {
        panel.classList.add('visible');
        btn.classList.add('active');
        fetchFleetHierarchy();
      } else {
        panel.classList.remove('visible');
        btn.classList.remove('active');
      }
    }

    // Fetch fleet hierarchy from /api/agent-pool/status
    async function fetchFleetHierarchy() {
      try {
        const res = await fetch('/api/agent-pool/status');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        FleetLineageState.hierarchy = await res.json();
        renderFleetLineage();
        return FleetLineageState.hierarchy;
      } catch (err) {
        console.error('[FLEET] Failed to fetch hierarchy:', err);
        document.getElementById('fleetHierarchyContainer').innerHTML =
          '<div class="fleet-lineage-empty">Failed to load agent hierarchy</div>';
        return null;
      }
    }

    // Render fleet lineage tree
    function renderFleetLineage() {
      const content = document.getElementById('fleetHierarchyContainer');
      const hierarchy = FleetLineageState.hierarchy;

      if (!hierarchy || !hierarchy.tree || hierarchy.tree.length === 0) {
        content.innerHTML = '<div class="fleet-lineage-empty">No agent hierarchy data available</div>';
        return;
      }

      content.innerHTML = `<div class="lineage-tree">${renderLineageNodes(hierarchy.tree, '')}</div>`;
    }

    // Recursively render lineage nodes
    function renderLineageNodes(nodes, prefix) {
      if (!nodes || nodes.length === 0) return '';

      return nodes.map((node, index) => {
        const isLast = index === nodes.length - 1;
        const nodePrefix = prefix + (isLast ? ' ' : ' ');
        const childPrefix = prefix + (isLast ? '    ' : '   ');
        const isExpanded = FleetLineageState.expandedNodes.has(node.id);
        const hasChildren = node.children && node.children.length > 0;

        const statusClass = node.status === 'active' ? 'active' :
                           node.status === 'completed' ? 'completed' :
                           node.status === 'error' ? 'error' : 'idle';

        return `
          <div class="lineage-node" data-node-id="${node.id}" onclick="toggleLineageNode('${node.id}')">
            <span class="lineage-node-prefix">${nodePrefix}</span>
            <div class="lineage-node-status ${statusClass}"></div>
            <span class="lineage-node-label">${node.label || node.id}</span>
            ${hasChildren ? `<span style="color: var(--text-muted)">[${node.children.length}]</span>` : ''}
            <span class="lineage-node-meta">${node.taskId || ''}</span>
          </div>
          ${hasChildren ? `<div class="lineage-node-children ${isExpanded ? '' : 'collapsed'}" data-parent="${node.id}">
            ${renderLineageNodes(node.children, childPrefix)}
          </div>` : ''}
        `;
      }).join('');
    }

    // Toggle lineage node expand/collapse
    function toggleLineageNode(nodeId) {
      const childrenEl = document.querySelector(`.lineage-node-children[data-parent="${nodeId}"]`);
      if (!childrenEl) return;

      if (FleetLineageState.expandedNodes.has(nodeId)) {
        FleetLineageState.expandedNodes.delete(nodeId);
        childrenEl.classList.add('collapsed');
      } else {
        FleetLineageState.expandedNodes.add(nodeId);
        childrenEl.classList.remove('collapsed');
      }
    }

    // Expand all lineage nodes
    function expandAllLineage() {
      document.querySelectorAll('.lineage-node-children').forEach(el => {
        el.classList.remove('collapsed');
        const parentId = el.dataset.parent;
        if (parentId) FleetLineageState.expandedNodes.add(parentId);
      });
    }

    // Collapse all lineage nodes
    function collapseAllLineage() {
      document.querySelectorAll('.lineage-node-children').forEach(el => {
        el.classList.add('collapsed');
      });
      FleetLineageState.expandedNodes.clear();
    }

    // Refresh fleet lineage
    function refreshFleetLineage() {
      fetchFleetHierarchy();
    }

    // Start fleet management on page load
    async function initFleetManagement() {
      await fetchFleetOverview();
      initFleetWebSocket();

      // Refresh fleet data periodically (in addition to SSE/WS updates)
      setInterval(fetchFleetOverview, 30000);
    }

    // Initialize
    init();
  </script>

  <!-- Toast Container (for notifications) -->
  <div class="toast-container" id="toastContainer"></div>
</body>
</html>
