<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Command Center v2</title>
  <style>
    :root {
      /* Dark theme - GitHub style */
      --bg-primary: #0d1117;
      --bg-secondary: #161b22;
      --bg-tertiary: #21262d;
      --bg-hover: #30363d;
      --border-color: #30363d;
      --border-muted: #21262d;

      /* Text colors */
      --text-primary: #e6edf3;
      --text-secondary: #8b949e;
      --text-muted: #6e7681;

      /* Status colors */
      --color-success: #3fb950;
      --color-warning: #d29922;
      --color-danger: #f85149;
      --color-info: #58a6ff;
      --color-purple: #a371f7;

      /* Quality thresholds */
      --quality-excellent: #3fb950;  /* 85+ */
      --quality-good: #3fb950;       /* 75-84 */
      --quality-warning: #d29922;    /* 50-74 */
      --quality-critical: #f85149;   /* <50 */
      --quality-idle: #6e7681;

      /* Layout */
      --sidebar-width: 340px;
      --header-height: 48px;
      --status-bar-height: 40px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.5;
      overflow: hidden;
      height: 100vh;
    }

    /* ===== LAYOUT ===== */
    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .header {
      height: var(--header-height);
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      flex-shrink: 0;
    }

    .header h1 {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header h1 .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--color-success);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .header-actions {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .header-btn {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .header-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    /* ===== TRAFFIC LIGHT STATUS BAR ===== */
    .status-bar {
      height: var(--status-bar-height);
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 16px;
      flex-shrink: 0;
    }

    .status-bar-label {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    .traffic-lights {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .traffic-light {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
      position: relative;
    }

    .traffic-light:hover {
      transform: scale(1.2);
    }

    .traffic-light.excellent { background: var(--quality-excellent); box-shadow: 0 0 8px var(--quality-excellent); }
    .traffic-light.good { background: var(--quality-good); }
    .traffic-light.warning { background: var(--quality-warning); box-shadow: 0 0 8px var(--quality-warning); }
    .traffic-light.critical { background: var(--quality-critical); box-shadow: 0 0 8px var(--quality-critical); animation: blink 1s infinite; }
    .traffic-light.idle { background: var(--quality-idle); }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .traffic-light-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      white-space: nowrap;
      display: none;
      z-index: 100;
    }

    .traffic-light:hover .traffic-light-tooltip {
      display: block;
    }

    .status-summary {
      font-size: 12px;
      color: var(--text-secondary);
      margin-left: auto;
    }

    .usage-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      background: var(--bg-tertiary);
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      cursor: pointer;
    }

    .usage-badge:hover {
      background: var(--bg-hover);
    }

    .usage-badge .bar {
      width: 60px;
      height: 4px;
      background: var(--bg-hover);
      border-radius: 2px;
      overflow: hidden;
    }

    .usage-badge .bar-fill {
      height: 100%;
      background: var(--color-success);
      transition: width 0.3s, background 0.3s;
    }

    .usage-badge .bar-fill.warning { background: var(--color-warning); }
    .usage-badge .bar-fill.critical { background: var(--color-danger); }

    /* ===== MAIN CONTENT (SPLIT PANE) ===== */
    .main-content {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* ===== SESSION LIST (LEFT PANE) ===== */
    .session-list {
      width: var(--sidebar-width);
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .session-list-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .session-filters {
      display: flex;
      gap: 8px;
      padding: 6px 12px;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      flex-wrap: wrap;
    }

    .filter-checkbox {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: var(--text-muted);
      cursor: pointer;
    }

    .filter-checkbox input[type="checkbox"] {
      width: 12px;
      height: 12px;
      margin: 0;
      cursor: pointer;
    }

    .filter-checkbox:hover {
      color: var(--text-primary);
    }

    .session-group {
      border-bottom: 1px solid var(--border-color);
    }

    .session-group-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .session-group-header:hover {
      background: var(--bg-secondary);
    }

    .session-group-toggle {
      font-size: 10px;
      transition: transform 0.2s;
    }

    .session-group.collapsed .session-group-toggle {
      transform: rotate(-90deg);
    }

    .session-group.collapsed .session-group-items {
      display: none;
    }

    .session-group-count {
      color: var(--text-muted);
      font-weight: normal;
    }

    .session-type-badge {
      font-size: 9px;
      padding: 1px 4px;
      border-radius: 3px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .session-type-badge.cli {
      background: var(--color-info);
      color: white;
    }

    .session-type-badge.autonomous {
      background: var(--color-warning);
      color: #1a1a1a;
    }

    .session-id-text {
      font-size: 9px;
      color: var(--text-muted);
      font-family: monospace;
    }

    .session-list-header h2 {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--text-muted);
      letter-spacing: 0.5px;
    }

    .session-count {
      font-size: 11px;
      background: var(--bg-tertiary);
      padding: 2px 8px;
      border-radius: 10px;
      color: var(--text-secondary);
    }

    .session-items {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .session-item {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
    }

    .session-item:hover {
      border-color: var(--color-info);
      background: var(--bg-hover);
    }

    .session-item.selected {
      border-color: var(--color-info);
      background: rgba(88, 166, 255, 0.1);
    }

    .session-item.warning {
      border-left: 3px solid var(--color-warning);
    }

    .session-item.critical {
      border-left: 3px solid var(--color-danger);
    }

    .session-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .session-name {
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .session-name .autonomous-badge {
      font-size: 12px;
    }

    .quality-badge {
      font-size: 12px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 10px;
      min-width: 36px;
      text-align: center;
    }

    .quality-badge.excellent { background: rgba(63, 185, 80, 0.2); color: var(--quality-excellent); }
    .quality-badge.good { background: rgba(63, 185, 80, 0.15); color: var(--quality-good); }
    .quality-badge.warning { background: rgba(210, 153, 34, 0.2); color: var(--quality-warning); }
    .quality-badge.critical { background: rgba(248, 81, 73, 0.2); color: var(--quality-critical); }
    .quality-badge.idle { background: var(--bg-hover); color: var(--text-muted); }

    .session-task {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .phase-badge {
      font-size: 10px;
      text-transform: uppercase;
      padding: 2px 6px;
      border-radius: 4px;
      background: var(--bg-hover);
      color: var(--text-muted);
    }

    .phase-badge.research { background: rgba(163, 113, 247, 0.2); color: var(--color-purple); }
    .phase-badge.design { background: rgba(88, 166, 255, 0.2); color: var(--color-info); }
    .phase-badge.implement { background: rgba(63, 185, 80, 0.2); color: var(--color-success); }
    .phase-badge.test { background: rgba(210, 153, 34, 0.2); color: var(--color-warning); }

    /* Phase Progression Indicator */
    .phase-progression {
      display: flex;
      align-items: center;
      gap: 4px;
      margin: 8px 0;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border-radius: 6px;
    }

    .phase-step {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .phase-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .phase-dot.pending {
      background: var(--bg-hover);
      color: var(--text-muted);
      border: 2px solid var(--border-color);
    }

    .phase-dot.current {
      background: var(--color-info);
      color: white;
      border: 2px solid var(--color-info);
      animation: pulse 2s infinite;
    }

    .phase-dot.completed {
      background: var(--color-success);
      color: white;
      border: 2px solid var(--color-success);
    }

    .phase-label {
      font-size: 9px;
      text-transform: uppercase;
      color: var(--text-muted);
      letter-spacing: 0.5px;
    }

    .phase-label.current {
      color: var(--color-info);
      font-weight: 600;
    }

    .phase-label.completed {
      color: var(--color-success);
    }

    .phase-connector {
      width: 20px;
      height: 2px;
      background: var(--border-color);
    }

    .phase-connector.completed {
      background: var(--color-success);
    }

    .phase-score {
      font-size: 8px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(88, 166, 255, 0.4); }
      50% { box-shadow: 0 0 0 6px rgba(88, 166, 255, 0); }
    }

    .session-metrics {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .session-metrics span {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .session-controls {
      display: flex;
      gap: 6px;
    }

    .control-btn {
      flex: 1;
      padding: 6px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.15s;
    }

    .control-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .control-btn.pause:hover { border-color: var(--color-warning); color: var(--color-warning); }
    .control-btn.skip:hover { border-color: var(--color-info); color: var(--color-info); }
    .control-btn.end:hover { border-color: var(--color-danger); color: var(--color-danger); }

    /* ===== DETAIL PANEL (RIGHT PANE) ===== */
    .detail-panel {
      flex: 1;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .detail-empty {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      font-size: 14px;
    }

    .detail-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .detail-title {
      font-size: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .detail-actions {
      display: flex;
      gap: 8px;
    }

    .detail-btn {
      padding: 8px 16px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
    }

    .detail-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .detail-btn.primary {
      background: var(--color-info);
      border-color: var(--color-info);
      color: white;
    }

    .detail-btn.danger {
      border-color: var(--color-danger);
      color: var(--color-danger);
    }

    .detail-btn.danger:hover {
      background: rgba(248, 81, 73, 0.1);
    }

    /* ===== METRICS GRID ===== */
    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .metric-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px 16px;
    }

    .metric-card.health { border-left: 3px solid var(--color-success); }
    .metric-card.warning { border-left: 3px solid var(--color-warning); }
    .metric-card.critical { border-left: 3px solid var(--color-danger); }

    .metric-label {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .metric-value {
      font-size: 24px;
      font-weight: 600;
    }

    .metric-value.success { color: var(--color-success); }
    .metric-value.warning { color: var(--color-warning); }
    .metric-value.danger { color: var(--color-danger); }

    .metric-detail {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    /* ===== DETAIL CONTENT ===== */
    .detail-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px 20px;
    }

    .detail-section {
      margin-bottom: 24px;
    }

    .detail-section h3 {
      font-size: 12px;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 12px;
      font-weight: 600;
      letter-spacing: 0.5px;
    }

    /* ===== CURRENT TASK ===== */
    .task-card {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
    }

    .task-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 12px;
    }

    .task-title {
      font-size: 16px;
      font-weight: 600;
    }

    .task-meta {
      display: flex;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    .acceptance-list {
      list-style: none;
    }

    .acceptance-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 6px 0;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .acceptance-item.done {
      color: var(--color-success);
    }

    .acceptance-item .check {
      width: 16px;
      height: 16px;
      border: 1px solid var(--border-color);
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 10px;
    }

    .acceptance-item.done .check {
      background: var(--color-success);
      border-color: var(--color-success);
      color: white;
    }

    /* ===== TASK QUEUE ===== */
    .queue-list {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .queue-item {
      display: flex;
      align-items: center;
      padding: 10px 16px;
      border-bottom: 1px solid var(--border-color);
      font-size: 13px;
    }

    .queue-item:last-child {
      border-bottom: none;
    }

    .queue-item.next {
      background: rgba(88, 166, 255, 0.1);
    }

    .queue-number {
      width: 24px;
      color: var(--text-muted);
      font-size: 11px;
    }

    .queue-task {
      flex: 1;
    }

    .queue-priority {
      font-size: 10px;
      text-transform: uppercase;
      padding: 2px 6px;
      border-radius: 4px;
      background: var(--bg-hover);
      color: var(--text-muted);
    }

    .queue-priority.critical { background: rgba(248, 81, 73, 0.2); color: var(--color-danger); }
    .queue-priority.high { background: rgba(210, 153, 34, 0.2); color: var(--color-warning); }

    /* ===== CLAIM BADGES ===== */
    .claim-badge {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .claim-badge.claimed {
      background: rgba(88, 166, 255, 0.2);
      color: var(--color-info);
    }

    .claim-badge.claimed-by-me {
      background: rgba(63, 185, 80, 0.2);
      color: var(--color-success);
    }

    .claim-badge.available {
      background: var(--bg-hover);
      color: var(--text-muted);
    }

    .claim-badge.stale {
      background: rgba(210, 153, 34, 0.2);
      color: var(--color-warning);
      animation: pulse 2s infinite;
    }

    .claim-session-id {
      font-size: 8px;
      color: var(--text-muted);
      font-family: monospace;
      max-width: 60px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .queue-item.claimed {
      border-left: 3px solid var(--color-info);
    }

    .queue-item.claimed-by-me {
      border-left: 3px solid var(--color-success);
      background: rgba(63, 185, 80, 0.05);
    }

    .queue-item.stale-claim {
      border-left: 3px solid var(--color-warning);
    }

    .session-task .claim-indicator {
      font-size: 10px;
      margin-left: 4px;
    }

    .session-task .claim-indicator.owned {
      color: var(--color-success);
    }

    .session-task .claim-indicator.stale {
      color: var(--color-warning);
    }

    /* Task queue filters */
    .queue-filters {
      display: flex;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
      flex-wrap: wrap;
    }

    .queue-filter-btn {
      font-size: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      background: var(--bg-hover);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
    }

    .queue-filter-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .queue-filter-btn.active {
      background: var(--color-info);
      border-color: var(--color-info);
      color: white;
    }

    .claim-stats {
      display: flex;
      gap: 12px;
      font-size: 11px;
      color: var(--text-muted);
      padding: 4px 0;
    }

    .claim-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .claim-stat-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .claim-stat-dot.claimed { background: var(--color-info); }
    .claim-stat-dot.available { background: var(--color-success); }
    .claim-stat-dot.stale { background: var(--color-warning); }

    /* ===== LOG VIEWER ===== */
    .log-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
    }

    .log-header:hover {
      background: var(--bg-hover);
    }

    .log-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      font-weight: 600;
    }

    .log-streaming-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--color-success);
      animation: pulse 2s infinite;
    }

    .log-controls {
      display: flex;
      gap: 8px;
    }

    .log-content {
      height: 200px;
      overflow-y: auto;
      font-family: 'SF Mono', 'Consolas', monospace;
      font-size: 11px;
      padding: 12px 16px;
      background: var(--bg-primary);
    }

    .log-line {
      padding: 2px 0;
      color: var(--text-secondary);
    }

    .log-line.error { color: var(--color-danger); }
    .log-line.warn { color: var(--color-warning); }
    .log-line.info { color: var(--color-info); }

    /* ===== LESSONS LEARNED ===== */
    .lessons-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .lessons-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
      gap: 12px;
    }

    .lessons-header:hover {
      background: var(--bg-hover);
    }

    .lessons-title {
      font-size: 12px;
      font-weight: 600;
    }

    .lessons-count {
      font-size: 11px;
      color: var(--text-muted);
      background: var(--bg-tertiary);
      padding: 2px 8px;
      border-radius: 10px;
      margin-left: auto;
    }

    .lessons-content {
      max-height: 300px;
      overflow-y: auto;
      padding: 12px 16px;
    }

    .lessons-empty {
      color: var(--text-muted);
      text-align: center;
      padding: 20px;
      font-size: 13px;
    }

    .lesson-item {
      padding: 12px;
      background: var(--bg-tertiary);
      border-radius: 6px;
      margin-bottom: 8px;
      border-left: 3px solid var(--color-info);
    }

    .lesson-item:last-child {
      margin-bottom: 0;
    }

    .lesson-item.success { border-left-color: var(--color-success); }
    .lesson-item.warning { border-left-color: var(--color-warning); }
    .lesson-item.error { border-left-color: var(--color-danger); }

    .lesson-task {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
    }

    .lesson-text {
      font-size: 13px;
      color: var(--text-primary);
      line-height: 1.4;
    }

    .lesson-tags {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .lesson-tag {
      font-size: 10px;
      padding: 2px 6px;
      background: var(--bg-hover);
      border-radius: 4px;
      color: var(--text-muted);
    }

    /* ===== USAGE LIMITS DROPDOWN ===== */
    .usage-dropdown {
      position: absolute;
      top: 100%;
      right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      min-width: 320px;
      display: none;
      z-index: 200;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    .usage-dropdown.open {
      display: block;
    }

    .usage-limit {
      margin-bottom: 16px;
    }

    .usage-limit:last-child {
      margin-bottom: 0;
    }

    .usage-limit-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .usage-limit-name {
      font-weight: 600;
    }

    .usage-limit-value {
      color: var(--text-muted);
    }

    .usage-limit-bar {
      height: 6px;
      background: var(--bg-hover);
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 4px;
    }

    .usage-limit-fill {
      height: 100%;
      background: var(--color-success);
      transition: width 0.3s;
    }

    .usage-limit-fill.warning { background: var(--color-warning); }
    .usage-limit-fill.critical { background: var(--color-danger); }

    .usage-limit-meta {
      font-size: 10px;
      color: var(--text-muted);
    }

    /* ===== SETTINGS MODAL ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.open {
      display: flex;
    }

    .modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h2 {
      font-size: 16px;
      font-weight: 600;
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 20px;
      padding: 4px;
    }

    .modal-close:hover {
      color: var(--text-primary);
    }

    .modal-body {
      padding: 20px;
      overflow-y: auto;
    }

    .settings-section {
      margin-bottom: 24px;
    }

    .settings-section h3 {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-secondary);
    }

    .settings-option {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid var(--border-muted);
    }

    .settings-option:last-child {
      border-bottom: none;
    }

    .settings-label {
      font-size: 13px;
    }

    .settings-description {
      font-size: 11px;
      color: var(--text-muted);
    }

    .toggle {
      width: 40px;
      height: 22px;
      background: var(--bg-hover);
      border-radius: 11px;
      position: relative;
      cursor: pointer;
      transition: background 0.2s;
    }

    .toggle.active {
      background: var(--color-success);
    }

    .toggle::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: left 0.2s;
    }

    .toggle.active::after {
      left: 20px;
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 900px) {
      .session-list {
        width: 280px;
      }
    }

    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }

      .session-list {
        width: 100%;
        height: 40vh;
        border-right: none;
        border-bottom: 1px solid var(--border-color);
      }

      .detail-panel {
        height: 60vh;
      }

      .metrics-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .header-actions {
        gap: 6px;
      }

      .header-btn {
        padding: 4px 8px;
        font-size: 11px;
      }
    }

    /* Mobile (480px and below) */
    @media (max-width: 480px) {
      :root {
        --header-height: 44px;
        --status-bar-height: auto;
      }

      .header h1 {
        font-size: 14px;
      }

      .header-actions {
        gap: 4px;
      }

      .header-btn {
        padding: 4px 6px;
        font-size: 10px;
      }

      .status-bar {
        flex-wrap: wrap;
        padding: 8px 12px;
        gap: 8px;
      }

      .traffic-lights {
        order: 2;
        width: 100%;
        justify-content: center;
      }

      .usage-badge {
        order: 1;
      }

      .status-summary {
        order: 3;
        width: 100%;
        text-align: center;
        margin-left: 0;
      }

      .main-content {
        flex-direction: column;
      }

      .session-list {
        width: 100%;
        height: 35vh;
        min-height: 180px;
      }

      .detail-panel {
        height: 65vh;
      }

      .session-item {
        padding: 10px;
      }

      .session-name {
        font-size: 13px;
      }

      .session-metrics {
        flex-wrap: wrap;
        gap: 8px;
      }

      .session-controls {
        gap: 4px;
      }

      .control-btn {
        padding: 5px;
        font-size: 10px;
      }

      .metrics-grid {
        grid-template-columns: 1fr;
        gap: 8px;
        padding: 12px;
      }

      .metric-card {
        padding: 10px 12px;
      }

      .metric-value {
        font-size: 20px;
      }

      .detail-header {
        flex-direction: column;
        gap: 12px;
        padding: 12px 16px;
      }

      .detail-title {
        font-size: 16px;
      }

      .detail-actions {
        width: 100%;
        display: flex;
        gap: 6px;
      }

      .detail-btn {
        flex: 1;
        padding: 6px 10px;
        font-size: 12px;
        text-align: center;
      }

      .detail-content {
        padding: 12px 16px;
      }

      .task-card {
        padding: 12px;
      }

      .task-title {
        font-size: 14px;
      }

      .phase-progression {
        padding: 6px 8px;
        overflow-x: auto;
      }

      .phase-label {
        font-size: 8px;
      }

      .phase-connector {
        width: 12px;
      }

      .acceptance-item {
        font-size: 12px;
      }

      .log-content {
        height: 150px;
      }

      .modal {
        width: 95%;
        max-height: 85vh;
      }

      .usage-dropdown {
        min-width: 280px;
        right: -50px;
      }
    }

    /* Keyboard focus styles for accessibility */
    .session-item:focus,
    .control-btn:focus,
    .header-btn:focus,
    .detail-btn:focus,
    .toggle:focus,
    .traffic-light:focus {
      outline: 2px solid var(--color-info);
      outline-offset: 2px;
    }

    .session-item:focus-visible,
    .control-btn:focus-visible,
    .header-btn:focus-visible,
    .detail-btn:focus-visible {
      outline: 2px solid var(--color-info);
      outline-offset: 2px;
    }

    /* Skip link for screen readers */
    .skip-link {
      position: absolute;
      top: -40px;
      left: 0;
      background: var(--color-info);
      color: white;
      padding: 8px 16px;
      z-index: 1001;
      text-decoration: none;
      border-radius: 0 0 4px 0;
    }

    .skip-link:focus {
      top: 0;
    }

    /* ===== HIERARCHY VISUALIZATION ===== */
    .hierarchy-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 200px;
    }

    .hierarchy-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-color);
    }

    .hierarchy-panel-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .hierarchy-panel-actions {
      display: flex;
      gap: 6px;
    }

    .hierarchy-panel-actions button {
      padding: 4px 8px;
      font-size: 11px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .hierarchy-panel-actions button:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .hierarchy-panel-body {
      flex: 1;
      overflow: auto;
      padding: 12px;
      max-height: 300px;
    }

    .hierarchy-tree {
      font-size: 12px;
      line-height: 1.5;
    }

    .hierarchy-tree__node {
      position: relative;
      margin: 2px 0;
    }

    .hierarchy-tree__node-row {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s ease;
      background: transparent;
      border: 1px solid transparent;
    }

    .hierarchy-tree__node-row:hover {
      background: var(--bg-hover);
      border-color: var(--border-color);
    }

    .hierarchy-tree__toggle {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
      flex-shrink: 0;
      font-size: 10px;
    }

    .hierarchy-tree__toggle:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .hierarchy-tree__toggle-placeholder {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }

    .hierarchy-tree__status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .hierarchy-tree__status-dot--active {
      background: var(--color-success);
      box-shadow: 0 0 6px var(--color-success);
      animation: pulse 2s ease-in-out infinite;
    }

    .hierarchy-tree__status-dot--completed {
      background: var(--color-success);
    }

    .hierarchy-tree__status-dot--failed {
      background: var(--color-danger);
    }

    .hierarchy-tree__status-dot--pending {
      background: var(--color-warning);
    }

    .hierarchy-tree__status-dot--idle {
      background: var(--text-muted);
    }

    .hierarchy-tree__icon {
      font-size: 12px;
      flex-shrink: 0;
    }

    .hierarchy-tree__name {
      flex: 1;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .hierarchy-tree__badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 16px;
      height: 16px;
      padding: 0 4px;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-secondary);
      background-color: var(--bg-tertiary);
      border-radius: 8px;
    }

    .hierarchy-tree__children {
      margin-left: 16px;
      padding-left: 12px;
      border-left: 1px dashed var(--border-color);
    }

    .hierarchy-tree__node--expanded > .hierarchy-tree__node-row .hierarchy-tree__toggle {
      transform: rotate(90deg);
    }

    .hierarchy-tree__node--selected > .hierarchy-tree__node-row {
      background: rgba(88, 166, 255, 0.1);
      border-color: var(--color-info);
    }

    .hierarchy-tree__node--root > .hierarchy-tree__node-row {
      background: var(--bg-tertiary);
      border-color: var(--border-color);
      padding: 8px 12px;
    }

    .hierarchy-tree__metrics {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-left: auto;
      padding-left: 10px;
    }

    .hierarchy-tree__metric {
      display: flex;
      align-items: center;
      gap: 3px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .hierarchy-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 30px;
      color: var(--text-muted);
      text-align: center;
    }

    .hierarchy-empty-icon {
      font-size: 24px;
      margin-bottom: 8px;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <!-- Skip link for keyboard/screen reader users -->
  <a href="#sessionItems" class="skip-link" tabindex="1">Skip to session list</a>

  <div class="app-container">
    <!-- Header -->
    <header class="header" role="banner">
      <h1>
        <span class="status-dot" id="connectionDot" role="status" aria-label="Connection status: connected"></span>
        COMMAND CENTER
      </h1>
      <div class="header-actions">
        <button class="header-btn" onclick="toggleSettings()" aria-label="Open settings" tabindex="0">
          Settings
        </button>
        <button class="header-btn" onclick="window.open('global-dashboard-classic.html', '_blank')" aria-label="Open classic view in new tab" tabindex="0">
          Classic View
        </button>
      </div>
    </header>

    <!-- Traffic Light Status Bar -->
    <div class="status-bar" role="region" aria-label="Quality status overview">
      <span class="status-bar-label" id="qualityStatusLabel">Quality Status</span>
      <div class="traffic-lights" id="trafficLights" role="group" aria-labelledby="qualityStatusLabel">
        <!-- Populated by JS -->
      </div>
      <span class="status-summary" id="statusSummary" role="status" aria-live="polite">Loading...</span>

      <div style="position: relative; margin-left: auto;">
        <button class="usage-badge" onclick="toggleUsageDropdown()" aria-expanded="false" aria-controls="usageDropdown" aria-label="Usage limits" tabindex="0">
          <span>Usage</span>
          <div class="bar">
            <div class="bar-fill" id="usageBarFill" style="width: 0%"></div>
          </div>
          <span id="usagePercent">--%</span>
        </button>
        <div class="usage-dropdown" id="usageDropdown" role="dialog" aria-label="Usage limits breakdown">
          <div class="usage-limit">
            <div class="usage-limit-header">
              <span class="usage-limit-name">5-Hour Window</span>
              <span class="usage-limit-value" id="usage5h">--/--</span>
            </div>
            <div class="usage-limit-bar">
              <div class="usage-limit-fill" id="usage5hFill"></div>
            </div>
            <div class="usage-limit-meta" id="usage5hMeta">Resets in --</div>
          </div>
          <div class="usage-limit">
            <div class="usage-limit-header">
              <span class="usage-limit-name">Daily</span>
              <span class="usage-limit-value" id="usageDaily">--/--</span>
            </div>
            <div class="usage-limit-bar">
              <div class="usage-limit-fill" id="usageDailyFill"></div>
            </div>
            <div class="usage-limit-meta" id="usageDailyMeta">Resets in --</div>
          </div>
          <div class="usage-limit">
            <div class="usage-limit-header">
              <span class="usage-limit-name">Weekly</span>
              <span class="usage-limit-value" id="usageWeekly">--/--</span>
            </div>
            <div class="usage-limit-bar">
              <div class="usage-limit-fill" id="usageWeeklyFill"></div>
            </div>
            <div class="usage-limit-meta" id="usageWeeklyMeta">Resets on --</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Main Content (Split Pane) -->
    <main class="main-content" role="main">
      <!-- Session List (Left Pane) -->
      <nav class="session-list" role="navigation" aria-label="Session navigation">
        <div class="session-list-header">
          <h2 id="sessionsHeading">Sessions</h2>
          <span class="session-count" id="sessionCount" aria-label="Total sessions">0</span>
        </div>
        <div class="session-filters">
          <label class="filter-checkbox">
            <input type="checkbox" id="filterActiveOnly" onchange="updateSessionList()">
            <span>Active only</span>
          </label>
          <label class="filter-checkbox">
            <input type="checkbox" id="filterShowCli" checked onchange="updateSessionList()">
            <span>CLI</span>
          </label>
          <label class="filter-checkbox">
            <input type="checkbox" id="filterShowAuto" checked onchange="updateSessionList()">
            <span>Auto</span>
          </label>
          <label class="filter-checkbox">
            <input type="checkbox" id="filterGroupByProject" checked onchange="updateSessionList()">
            <span>Group</span>
          </label>
        </div>
        <div class="session-items" id="sessionItems" role="listbox" aria-labelledby="sessionsHeading" tabindex="0">
          <!-- Populated by JS -->
        </div>
      </nav>

      <!-- Detail Panel (Right Pane) -->
      <section class="detail-panel" id="detailPanel" role="region" aria-label="Session details" aria-live="polite">
        <div class="detail-empty" id="detailEmpty">
          Select a session to view details
        </div>
        <div id="detailContent" style="display: none; height: 100%; display: flex; flex-direction: column;">
          <!-- Populated by JS -->
        </div>
      </section>
    </main>
  </div>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
    <div class="modal">
      <div class="modal-header">
        <h2 id="settingsTitle">Settings</h2>
        <button class="modal-close" onclick="toggleSettings()" aria-label="Close settings" tabindex="0">&times;</button>
      </div>
      <div class="modal-body">
        <div class="settings-section">
          <h3>Health & Stability Metrics</h3>
          <div class="settings-option">
            <div>
              <div class="settings-label">Error Count</div>
              <div class="settings-description">Show task retry attempts and failures</div>
            </div>
            <div class="toggle active" data-setting="showErrorCount" onclick="toggleSetting(this)"></div>
          </div>
          <div class="settings-option">
            <div>
              <div class="settings-label">Quality Trend</div>
              <div class="settings-description">Show quality score direction (improving/declining)</div>
            </div>
            <div class="toggle active" data-setting="showQualityTrend" onclick="toggleSetting(this)"></div>
          </div>
          <div class="settings-option">
            <div>
              <div class="settings-label">Blocking Issues</div>
              <div class="settings-description">Highlight tasks that block other work</div>
            </div>
            <div class="toggle active" data-setting="showBlockingIssues" onclick="toggleSetting(this)"></div>
          </div>
        </div>

        <div class="settings-section">
          <h3>Progress & Velocity Metrics</h3>
          <div class="settings-option">
            <div>
              <div class="settings-label">Token Burn Rate</div>
              <div class="settings-description">Show tokens consumed per hour</div>
            </div>
            <div class="toggle active" data-setting="showTokenBurnRate" onclick="toggleSetting(this)"></div>
          </div>
          <div class="settings-option">
            <div>
              <div class="settings-label">Context Exhaustion ETA</div>
              <div class="settings-description">Predicted time until context limit</div>
            </div>
            <div class="toggle active" data-setting="showExhaustionETA" onclick="toggleSetting(this)"></div>
          </div>
          <div class="settings-option">
            <div>
              <div class="settings-label">Acceptance Progress</div>
              <div class="settings-description">Show criteria completion percentage</div>
            </div>
            <div class="toggle active" data-setting="showAcceptanceProgress" onclick="toggleSetting(this)"></div>
          </div>
        </div>

        <div class="settings-section">
          <h3>Resource & Cost Metrics</h3>
          <div class="settings-option">
            <div>
              <div class="settings-label">Cost Display</div>
              <div class="settings-description">Show session and total costs</div>
            </div>
            <div class="toggle" data-setting="showCost" onclick="toggleSetting(this)"></div>
          </div>
          <div class="settings-option">
            <div>
              <div class="settings-label">Model Usage</div>
              <div class="settings-description">Show which AI model is being used</div>
            </div>
            <div class="toggle" data-setting="showModel" onclick="toggleSetting(this)"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== STATE =====
    let sessions = [];
    let selectedSessionId = null;
    let predictions = {};
    let usageLimits = {};
    let eventSource = null;
    // Per-project task/execution data (key = project path)
    const projectDataMap = new Map();
    // Legacy single-project references (for backward compatibility)
    let tasksData = { tasks: [], stats: {} };
    let executionState = {};
    // Claims data for task ownership tracking
    let claimsData = {
      claims: [],           // All active claims from /api/tasks/in-flight
      stats: {},            // Claim statistics
      lastFetched: null     // Timestamp of last fetch
    };
    // Queue filter state
    let queueFilter = 'all'; // 'all', 'claimed', 'available', 'mine'

    // Settings (persisted to localStorage)
    let settings = {
      showErrorCount: true,
      showQualityTrend: true,
      showBlockingIssues: true,
      showTokenBurnRate: true,
      showExhaustionETA: true,
      showAcceptanceProgress: true,
      showCost: false,
      showModel: false
    };

    // Load settings from localStorage
    const savedSettings = localStorage.getItem('dashboardSettings');
    if (savedSettings) {
      settings = { ...settings, ...JSON.parse(savedSettings) };
    }

    // Phase progression configuration
    const PHASES = ['research', 'design', 'implement', 'test'];

    // Render phase progression indicator for a task
    function renderPhaseProgression(taskId, currentPhase) {
      const taskPhases = executionState.taskPhaseHistory?.[taskId] || {
        phases: [],
        currentPhase: currentPhase,
        scores: {}
      };

      const completedPhases = taskPhases.phases || [];
      const activePhase = taskPhases.currentPhase || currentPhase;

      return `
        <div class="phase-progression">
          ${PHASES.map((phase, idx) => {
            const isCompleted = completedPhases.includes(phase);
            const isCurrent = phase === activePhase && !isCompleted;
            const isPending = !isCompleted && !isCurrent;
            const score = taskPhases.scores?.[phase];

            const statusClass = isCompleted ? 'completed' : (isCurrent ? 'current' : 'pending');
            const icon = isCompleted ? '✓' : (isCurrent ? '●' : (idx + 1));

            const connector = idx < PHASES.length - 1 ? `
              <div class="phase-connector ${isCompleted ? 'completed' : ''}"></div>
            ` : '';

            return `
              <div class="phase-step">
                <div style="display: flex; flex-direction: column; align-items: center;">
                  <div class="phase-dot ${statusClass}">${icon}</div>
                  <span class="phase-label ${statusClass}">${phase}</span>
                  ${score ? `<span class="phase-score">${score}</span>` : ''}
                </div>
              </div>
              ${connector}
            `;
          }).join('')}
        </div>
      `;
    }

    // ===== INITIALIZATION =====
    async function init() {
      loadSettingsUI();

      // Fetch sessions first, then enrich with task/execution data
      await fetchSessions();
      await fetchTasksAndExecution(); // Enrich immediately after

      // Then fetch other data in parallel (including claims)
      await Promise.all([
        fetchUsageLimits(),
        fetchPredictions(),
        fetchInFlightTasks()
      ]);

      // Now connect SSE (which will preserve enriched data)
      connectSSE();

      // Refresh usage limits every minute
      setInterval(fetchUsageLimits, 60000);
      // Refresh tasks every 10 seconds (reduced frequency to prevent flicker)
      setInterval(fetchTasksAndExecution, 10000);
      // Refresh claims every 15 seconds
      setInterval(fetchInFlightTasks, 15000);
    }

    async function fetchTasksAndExecution() {
      try {
        // Get unique project paths from all sessions
        const uniqueProjectPaths = new Set();
        for (const session of sessions) {
          if (session.path) {
            uniqueProjectPaths.add(session.path);
          }
        }

        // If no sessions with paths, fetch default project data
        if (uniqueProjectPaths.size === 0) {
          const [tasksRes, execRes] = await Promise.all([
            fetch('/api/tasks'),
            fetch('/api/execution')
          ]);
          tasksData = await tasksRes.json();
          executionState = await execRes.json();
          enrichActiveSession();
          return;
        }

        // Fetch tasks and execution state for EACH unique project
        const fetchPromises = [];
        const projectPaths = Array.from(uniqueProjectPaths);

        for (const projectPath of projectPaths) {
          const encodedPath = encodeURIComponent(projectPath);
          fetchPromises.push(
            Promise.all([
              fetch(`/api/tasks?projectPath=${encodedPath}`),
              fetch(`/api/execution?projectPath=${encodedPath}`)
            ]).then(async ([tasksRes, execRes]) => ({
              projectPath,
              tasks: await tasksRes.json(),
              execution: await execRes.json()
            }))
          );
        }

        // Wait for all fetches to complete
        const results = await Promise.all(fetchPromises);
        let anyChanged = false;

        // Store results in the projectDataMap
        for (const result of results) {
          const oldData = projectDataMap.get(result.projectPath);
          const newData = {
            tasks: result.tasks,
            execution: result.execution
          };

          // Check if data changed for this project
          const tasksChanged = !oldData || JSON.stringify(oldData.tasks?.stats) !== JSON.stringify(newData.tasks?.stats);
          const execChanged = !oldData || JSON.stringify(oldData.execution?.qualityScores) !== JSON.stringify(newData.execution?.qualityScores);

          if (tasksChanged || execChanged) {
            anyChanged = true;
          }

          projectDataMap.set(result.projectPath, newData);
        }

        // Update legacy references with first project's data (for backward compatibility)
        if (results.length > 0) {
          tasksData = results[0].tasks;
          executionState = results[0].execution;
        }

        // Enrich sessions with their project's data
        enrichActiveSession();

        // Only update UI if data changed
        if (anyChanged) {
          updateTrafficLights();
          updateSessionList();
          if (selectedSessionId) {
            updateDetailPanel();
          }
        }
      } catch (err) {
        console.error('Failed to fetch tasks/execution:', err);
      }
    }

    function enrichActiveSession() {
      // Group sessions by project path for per-project enrichment
      const sessionsByPath = new Map();

      for (const session of sessions) {
        const projectPath = session.path;
        if (!projectPath) continue;

        if (!sessionsByPath.has(projectPath)) {
          sessionsByPath.set(projectPath, []);
        }
        sessionsByPath.get(projectPath).push(session);
      }

      // Enrich each project's sessions with that project's data
      for (const [projectPath, projectSessions] of sessionsByPath) {
        // Get this project's data from the map
        const projectData = projectDataMap.get(projectPath) || {
          tasks: { tasks: [], stats: {} },
          execution: {}
        };

        const projectTasksData = projectData.tasks || { tasks: [], stats: {} };
        const projectExecutionState = projectData.execution || {};

        // Build task data for this project
        let taskQueue = [];
        let currentTask = null;

        if (projectTasksData.tasks && projectTasksData.tasks.length > 0) {
          taskQueue = projectTasksData.tasks
            .filter(t => t.status === 'ready')
            .sort((a, b) => {
              const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
              return (priorityOrder[a.priority] || 2) - (priorityOrder[b.priority] || 2);
            })
            .slice(0, 10);

          const inProgressTask = projectTasksData.tasks.find(t => t.status === 'in_progress');
          if (inProgressTask) {
            currentTask = {
              id: inProgressTask.id,
              title: inProgressTask.title,
              description: inProgressTask.description,
              phase: inProgressTask.phase || projectExecutionState.currentPhase,
              priority: inProgressTask.priority,
              estimate: inProgressTask.estimate,
              acceptance: (inProgressTask.acceptance || []).map(a =>
                typeof a === 'string' ? { text: a, done: false } : a
              ),
              attempts: inProgressTask.attempts || 1
            };
          } else if (taskQueue.length > 0) {
            const nextTask = taskQueue[0];
            currentTask = {
              id: nextTask.id,
              title: nextTask.title,
              description: nextTask.description,
              phase: nextTask.phase || projectExecutionState.currentPhase,
              priority: nextTask.priority,
              estimate: nextTask.estimate,
              acceptance: (nextTask.acceptance || []).map(a =>
                typeof a === 'string' ? { text: a, done: false } : a
              ),
              attempts: 1
            };
          }
        }

        // Apply this project's data to its sessions
        for (const session of projectSessions) {
          // Only set phase if session doesn't have its own
          if (projectExecutionState.currentPhase && !session.phase) {
            session.phase = projectExecutionState.currentPhase;
            session.iteration = projectExecutionState.phaseIteration || 1;
          }
          // DON'T overwrite session-specific quality scores
          // Each session tracks its own quality from the session registry

          // Task queue and stats are project-level, safe to share within project
          session.taskQueue = taskQueue;
          session.currentTask = currentTask;
          session.taskStats = projectTasksData.stats || {};
        }
      }
    }

    // ===== DATA FETCHING =====
    async function fetchSessions() {
      try {
        // Fetch both projects (CLI sessions) and sessions/summary (autonomous orchestrator sessions)
        const [projectsRes, summaryRes] = await Promise.all([
          fetch('/api/projects'),
          fetch('/api/sessions/summary')
        ]);
        const projectsData = await projectsRes.json();
        const summaryData = await summaryRes.json();

        // Build list of ALL sessions - never merge CLI and autonomous
        const allSessions = [];

        // 1. Add all CLI sessions from projects (each as separate entry)
        for (const p of (projectsData.projects || [])) {
          // Filter out agent-* sessions (subagent tasks) - they should roll up to parent
          const cliSessions = (p.sessions || []).filter(s => {
            const id = s.id || '';
            return !id.startsWith('agent-') && !id.includes('/agent-');
          });

          // Always show each CLI session separately
          for (const cliSession of cliSessions) {
            // Double-check: skip if this is an agent session
            if (cliSession.id?.startsWith('agent-')) continue;

            const sessionId = `cli-${p.folder}-${cliSession.id}`;
            const existingSession = sessions.find(s => s.id === sessionId);

            // Consider session active if:
            // 1. Project is marked active, OR
            // 2. Session is marked as current, OR
            // 3. Has activity within the last 5 minutes
            const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
            const lastUpdateTime = typeof cliSession.lastUpdate === 'number' ? cliSession.lastUpdate : 0;
            const hasRecentActivity = lastUpdateTime > fiveMinutesAgo;
            const isActive = p.status === 'active' || cliSession.isActive || hasRecentActivity;

            allSessions.push({
              id: sessionId,
              project: p.name,
              path: p.path,
              folder: p.folder,
              cliSessionId: cliSession.id,
              sessionType: 'cli',
              status: isActive ? 'active' : 'idle',
              // Use per-session context (fallback to project for backward compat)
              contextPercent: cliSession.contextPercent ?? p.metrics?.contextPercent ?? 0,
              contextUsed: cliSession.contextUsed ?? p.metrics?.contextUsed ?? 0,
              qualityScore: existingSession?.qualityScore || 0,
              qualityBreakdown: existingSession?.qualityBreakdown || {},
              // Use per-session cost (fallback to project for backward compat)
              cost: cliSession.cost ?? p.metrics?.cost ?? 0,
              tokens: cliSession.inputTokens + cliSession.outputTokens,
              // Use per-session model (fallback to project for backward compat)
              model: cliSession.model ?? p.metrics?.model,
              messageCount: cliSession.messageCount || 0,
              currentTask: existingSession?.currentTask || null,
              taskQueue: existingSession?.taskQueue || [],
              taskStats: existingSession?.taskStats || {},
              phase: existingSession?.phase || null,
              autonomous: false,
              iteration: existingSession?.iteration || 1,
              safetyStatus: isActive ? p.safetyStatus : 'OK',
              logSessionId: null,
              orchestratorInfo: null,
              confidenceScore: null,
              registryId: null,
              lastUpdate: cliSession.lastUpdate,
              startTime: cliSession.lastUpdate, // For display
              // Phase 4: Claim-based current task (CLI sessions look up from claimsData)
              claimedTaskId: existingSession?.claimedTaskId || null,
              claimInfo: existingSession?.claimInfo || null
            });
          }

          // If no CLI sessions but project exists, still show it
          if (cliSessions.length === 0) {
            allSessions.push({
              id: `cli-${p.folder}-default`,
              project: p.name,
              path: p.path,
              folder: p.folder,
              cliSessionId: 'default',
              sessionType: 'cli',
              status: p.status === 'active' ? 'active' : 'idle',
              contextPercent: p.metrics?.contextPercent || 0,
              qualityScore: 0,
              qualityBreakdown: {},
              cost: p.metrics?.cost || 0,
              tokens: p.metrics?.contextUsed || 0,
              model: p.metrics?.model,
              messageCount: p.metrics?.messageCount || 0,
              currentTask: null,
              taskQueue: [],
              taskStats: {},
              phase: null,
              autonomous: false,
              iteration: 1,
              safetyStatus: p.safetyStatus,
              logSessionId: null,
              orchestratorInfo: null,
              confidenceScore: null,
              registryId: null,
              lastUpdate: p.metrics?.lastUpdate,
              startTime: p.metrics?.lastUpdate,
              // Phase 4: No claims for default placeholder sessions
              claimedTaskId: null,
              claimInfo: null
            });
          }
        }

        // 2. Add all autonomous sessions as separate entries (never merge)
        for (const s of (summaryData.sessions || [])) {
          if (s.status === 'ended') continue; // Skip ended sessions by default

          const projectName = s.project || s.path?.split(/[\\/]/).pop() || 'Unknown Project';
          const folder = s.path ? s.path.replace(/:/g, '').replace(/[\\/]/g, '-') : null;

          allSessions.push({
            id: `auto-${s.id}`,
            project: projectName,
            path: s.path,
            folder: folder,
            cliSessionId: null,
            sessionType: 'autonomous',
            status: s.status || 'active',
            contextPercent: s.contextPercent || 0,
            qualityScore: s.qualityScore || 0,
            qualityBreakdown: {},
            cost: s.cost || 0,
            tokens: s.tokens || 0,
            model: null,
            messageCount: 0,
            currentTask: s.currentTask || null,
            taskQueue: s.taskQueue || [],
            taskStats: {},
            phase: s.phase || null,
            autonomous: true,
            iteration: s.iteration || 1,
            safetyStatus: null,
            logSessionId: s.logSessionId || null,
            orchestratorInfo: s.orchestratorInfo || null,
            confidenceScore: s.confidenceScore || null,
            registryId: s.id,
            lastUpdate: s.lastUpdate || s.startTime,
            startTime: s.startTime,
            // Phase 4: Claim-based current task from /api/sessions/summary
            claimedTaskId: s.currentTaskId || null,
            claimInfo: s.claimInfo || null
          });
        }

        // Sort by: active first, then by lastUpdate (most recent first)
        allSessions.sort((a, b) => {
          // Active sessions first
          const aActive = a.status === 'active' ? 1 : 0;
          const bActive = b.status === 'active' ? 1 : 0;
          if (aActive !== bActive) return bActive - aActive;
          // Then by most recent activity
          return (b.lastUpdate || 0) - (a.lastUpdate || 0);
        });

        // Final filter: remove any sessions with agent IDs that slipped through
        sessions = allSessions.filter(s => {
          const cliId = s.cliSessionId || '';
          return !cliId.startsWith('agent-');
        });

        // Note: Enrichment with task/execution data happens in fetchTasksAndExecution()
        updateTrafficLights();
        updateSessionList();
      } catch (err) {
        console.error('Failed to fetch sessions:', err);
      }
    }

    async function fetchUsageLimits() {
      try {
        const res = await fetch('/api/usage/limits');
        usageLimits = await res.json();
        updateUsageDisplay();
      } catch (err) {
        console.error('Failed to fetch usage limits:', err);
      }
    }

    async function fetchPredictions() {
      try {
        const res = await fetch('/api/predictions');
        predictions = await res.json();
      } catch (err) {
        console.error('Failed to fetch predictions:', err);
      }
    }

    // Fetch all active task claims (in-flight tasks)
    async function fetchInFlightTasks() {
      try {
        const [claimsRes, statsRes] = await Promise.all([
          fetch('/api/tasks/in-flight'),
          fetch('/api/tasks/claims/stats')
        ]);

        if (claimsRes.ok) {
          const data = await claimsRes.json();
          claimsData.claims = data.claims || [];
          claimsData.lastFetched = Date.now();
        }

        if (statsRes.ok) {
          claimsData.stats = await statsRes.json();
        }
      } catch (err) {
        console.error('Failed to fetch in-flight tasks:', err);
      }
    }

    // Get claim info for a specific task
    function getClaimForTask(taskId) {
      return claimsData.claims.find(c => c.taskId === taskId);
    }

    // Check if a claim is stale (last heartbeat > 2 minutes ago)
    function isClaimStale(claim) {
      if (!claim || !claim.lastHeartbeat) return false;
      const twoMinutesAgo = Date.now() - (2 * 60 * 1000);
      const heartbeatTime = new Date(claim.lastHeartbeat).getTime();
      return heartbeatTime < twoMinutesAgo;
    }

    // Get claim status for a task (used for UI display)
    function getClaimStatus(taskId, currentSessionId) {
      const claim = getClaimForTask(taskId);
      if (!claim) return { status: 'available', claim: null };

      const isStale = isClaimStale(claim);
      const isMine = claim.sessionId === currentSessionId;

      if (isStale) return { status: 'stale', claim };
      if (isMine) return { status: 'mine', claim };
      return { status: 'claimed', claim };
    }

    // Format session ID for display (short version)
    function formatClaimSessionId(sessionId) {
      if (!sessionId) return '';
      // If it's a UUID, show last 8 chars
      if (sessionId.length > 12) {
        return sessionId.slice(-8);
      }
      return sessionId;
    }

    // Render claim badge for task queue
    function renderClaimBadge(claimStatus) {
      if (claimStatus.status === 'available') {
        return '<span class="claim-badge available">Available</span>';
      }
      if (claimStatus.status === 'mine') {
        return '<span class="claim-badge claimed-by-me">Mine</span>';
      }
      if (claimStatus.status === 'stale') {
        const shortId = formatClaimSessionId(claimStatus.claim?.sessionId);
        return `<span class="claim-badge stale" title="Claim may be stale - session ${shortId}">⚠ Stale</span>`;
      }
      // claimed by another session
      const shortId = formatClaimSessionId(claimStatus.claim?.sessionId);
      return `<span class="claim-badge claimed" title="Claimed by session ${shortId}">Claimed</span>`;
    }

    // Set queue filter and refresh
    function setQueueFilter(filter) {
      queueFilter = filter;
      if (selectedSessionId) {
        updateDetailPanel(sessions.find(s => s.id === selectedSessionId));
      }
    }

    // Handle claim events from SSE
    function handleClaimEvent(event) {
      const { type, taskId, sessionId, claim } = event;

      switch (type) {
        case 'task:claimed':
          // Add or update claim in local cache
          const existingIdx = claimsData.claims.findIndex(c => c.taskId === taskId);
          if (existingIdx >= 0) {
            claimsData.claims[existingIdx] = claim;
          } else {
            claimsData.claims.push(claim);
          }
          // Update session's claimed task if this is for a session we're tracking
          updateSessionClaimedTask(sessionId, taskId, claim);
          break;

        case 'task:released':
        case 'task:claim-expired':
        case 'task:claim-orphaned':
          // Remove claim from local cache
          claimsData.claims = claimsData.claims.filter(c => c.taskId !== taskId);
          // Clear session's claimed task
          clearSessionClaimedTask(sessionId, taskId);
          break;

        case 'task:claims-cleaned':
          // Multiple claims were cleaned - refetch all claims
          fetchInFlightTasks();
          break;
      }

      // Update UI
      updateSessionList();
      if (selectedSessionId) {
        updateDetailPanel(sessions.find(s => s.id === selectedSessionId));
      }
    }

    // Update a session's claimed task when claim event received
    function updateSessionClaimedTask(sessionId, taskId, claim) {
      // Find session by registryId (for autonomous) or construct CLI session ID
      for (const session of sessions) {
        const isMatch = session.registryId === sessionId ||
                        session.id === sessionId ||
                        session.cliSessionId === sessionId;
        if (isMatch) {
          session.claimedTaskId = taskId;
          session.claimInfo = claim;
          break;
        }
      }
    }

    // Clear a session's claimed task when claim is released
    function clearSessionClaimedTask(sessionId, taskId) {
      for (const session of sessions) {
        const isMatch = session.registryId === sessionId ||
                        session.id === sessionId ||
                        session.cliSessionId === sessionId;
        if (isMatch && session.claimedTaskId === taskId) {
          session.claimedTaskId = null;
          session.claimInfo = null;
          break;
        }
      }
    }

    function connectSSE() {
      eventSource = new EventSource('/api/events');

      eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          let needsUIUpdate = false;

          // Handle taskData from SSE (real-time task updates)
          if (data.taskData) {
            const newStats = data.taskData.stats;
            const oldStats = tasksData?.stats;

            // Check if task data actually changed
            if (JSON.stringify(newStats) !== JSON.stringify(oldStats)) {
              tasksData = {
                tasks: [...(data.taskData.inProgress || []), ...(data.taskData.ready || [])],
                stats: newStats
              };
              needsUIUpdate = true;
            }
          }

          // Handle executionState from SSE (phase, quality scores)
          if (data.executionState) {
            const newScores = data.executionState.qualityScores;
            const oldScores = executionState?.qualityScores;

            // Check if execution state changed
            if (JSON.stringify(newScores) !== JSON.stringify(oldScores)) {
              executionState = data.executionState;
              needsUIUpdate = true;
            }
          }

          // If task/execution data changed, enrich sessions
          if (needsUIUpdate) {
            enrichActiveSession();
          }

          // Handle projects data from SSE - update existing sessions in-place to avoid bouncing
          if (data.projects) {
            let anyChanged = false;

            // Update CLI sessions in-place
            for (const p of data.projects) {
              // Filter out agent-* sessions (subagent tasks)
              const cliSessions = (p.sessions || []).filter(s => {
                const id = s.id || '';
                return !id.startsWith('agent-') && !id.includes('/agent-');
              });
              const defaultSessionId = `cli-${p.folder}-default`;

              // If we have real sessions, remove any "default" placeholder
              if (cliSessions.length > 0) {
                const defaultIdx = sessions.findIndex(s => s.id === defaultSessionId);
                if (defaultIdx >= 0) {
                  sessions.splice(defaultIdx, 1);
                  anyChanged = true;
                }
              }

              for (const cliSession of cliSessions) {
                // Skip agent sessions
                if (cliSession.id?.startsWith('agent-')) continue;

                const sessionId = `cli-${p.folder}-${cliSession.id}`;
                const existing = sessions.find(s => s.id === sessionId);

                // Consider session active if project active, session current, or recent activity
                const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
                const lastUpdateTime = typeof cliSession.lastUpdate === 'number' ? cliSession.lastUpdate : 0;
                const hasRecentActivity = lastUpdateTime > fiveMinutesAgo;
                const isActive = p.status === 'active' || cliSession.isActive || hasRecentActivity;
                // Use per-session context (fallback to project for backward compat)
                const newContextPercent = cliSession.contextPercent ?? p.metrics?.contextPercent ?? 0;
                const newCost = cliSession.cost ?? p.metrics?.cost ?? 0;
                const newModel = cliSession.model ?? p.metrics?.model;

                if (existing) {
                  // Update in-place - only mark changed if values actually differ
                  const oldStatus = existing.status;
                  existing.status = isActive ? 'active' : 'idle';
                  existing.contextPercent = newContextPercent;
                  existing.contextUsed = cliSession.contextUsed ?? p.metrics?.contextUsed ?? 0;
                  existing.cost = isActive ? newCost : 0;
                  existing.tokens = cliSession.inputTokens + cliSession.outputTokens;
                  existing.model = newModel;
                  existing.messageCount = cliSession.messageCount || 0;
                  existing.safetyStatus = isActive ? p.safetyStatus : 'OK';
                  existing.lastUpdate = cliSession.lastUpdate;
                  if (oldStatus !== existing.status) anyChanged = true;
                } else {
                  // New session - add it
                  anyChanged = true;
                  sessions.push({
                    id: sessionId,
                    project: p.name,
                    path: p.path,
                    folder: p.folder,
                    cliSessionId: cliSession.id,
                    sessionType: 'cli',
                    status: isActive ? 'active' : 'idle',
                    contextPercent: newContextPercent,
                    contextUsed: cliSession.contextUsed ?? p.metrics?.contextUsed ?? 0,
                    cost: isActive ? newCost : 0,
                    tokens: cliSession.inputTokens + cliSession.outputTokens,
                    model: newModel,
                    messageCount: cliSession.messageCount || 0,
                    safetyStatus: isActive ? p.safetyStatus : 'OK',
                    qualityScore: 0,
                    qualityBreakdown: {},
                    currentTask: null,
                    taskQueue: [],
                    taskStats: {},
                    phase: null,
                    iteration: 1,
                    autonomous: false,
                    logSessionId: null,
                    orchestratorInfo: null,
                    confidenceScore: null,
                    registryId: null,
                    lastUpdate: cliSession.lastUpdate,
                    startTime: cliSession.lastUpdate
                  });
                }
              }

              // Only create default session if no real CLI sessions exist
              if (cliSessions.length === 0) {
                const existing = sessions.find(s => s.id === defaultSessionId);
                const newContextPercent = p.metrics?.contextPercent || 0;

                if (existing) {
                  const oldStatus = existing.status;
                  existing.status = p.status === 'active' ? 'active' : 'idle';
                  existing.contextPercent = newContextPercent;
                  existing.cost = p.metrics?.cost || 0;
                  existing.tokens = p.metrics?.contextUsed || 0;
                  existing.messageCount = p.metrics?.messageCount || 0;
                  existing.safetyStatus = p.safetyStatus;
                  existing.lastUpdate = p.metrics?.lastUpdate;
                  if (oldStatus !== existing.status) anyChanged = true;
                } else {
                  anyChanged = true;
                  sessions.push({
                    id: defaultSessionId,
                    project: p.name,
                    path: p.path,
                    folder: p.folder,
                    cliSessionId: 'default',
                    sessionType: 'cli',
                    status: p.status === 'active' ? 'active' : 'idle',
                    contextPercent: newContextPercent,
                    cost: p.metrics?.cost || 0,
                    tokens: p.metrics?.contextUsed || 0,
                    model: p.metrics?.model,
                    messageCount: p.metrics?.messageCount || 0,
                    safetyStatus: p.safetyStatus,
                    qualityScore: 0,
                    qualityBreakdown: {},
                    currentTask: null,
                    taskQueue: [],
                    taskStats: {},
                    phase: null,
                    iteration: 1,
                    autonomous: false,
                    logSessionId: null,
                    orchestratorInfo: null,
                    confidenceScore: null,
                    registryId: null,
                    lastUpdate: p.metrics?.lastUpdate,
                    startTime: p.metrics?.lastUpdate
                  });
                }
              }
            }

            // Update UI only if something actually changed (throttled to reduce jumping)
            if (anyChanged || needsUIUpdate) {
              throttledUIUpdate();
            }
          }

          // Handle hierarchy updates from SSE
          if (data.hierarchyUpdate) {
            const update = data.hierarchyUpdate;
            // Refresh hierarchy if it's for the currently selected session
            if (update.sessionId === HierarchyTreeState.currentSessionId) {
              if (update.type === 'full') {
                // Full refresh
                loadHierarchy(update.sessionId);
              } else if (update.type === 'node' && update.node) {
                // Incremental update - update specific node
                const existingNode = HierarchyTreeState.getNode(update.node.id);
                if (existingNode) {
                  existingNode.status = normalizeHierarchyStatus(update.node.status);
                  existingNode.metrics = update.node.metrics || existingNode.metrics;
                  // Re-render just that node's status
                  const nodeEl = document.querySelector(`[data-node-id="${update.node.id}"]`);
                  if (nodeEl) {
                    const statusDot = nodeEl.querySelector('.hierarchy-tree__status-dot');
                    if (statusDot) {
                      statusDot.className = `hierarchy-tree__status-dot hierarchy-tree__status-dot--${existingNode.status}`;
                    }
                  }
                }
              }
            }
          }

          // Handle claim events from SSE (task:claimed, task:released, task:claim-expired, etc.)
          if (data.claimEvent) {
            const event = data.claimEvent;
            handleClaimEvent(event);
          }
        } catch (err) {
          console.error('SSE parse error:', err);
        }
      };

      eventSource.onerror = () => {
        document.getElementById('connectionDot').style.background = 'var(--color-danger)';
        setTimeout(() => {
          eventSource.close();
          connectSSE();
        }, 3000);
      };

      eventSource.onopen = () => {
        document.getElementById('connectionDot').style.background = 'var(--color-success)';
      };
    }

    // ===== TRAFFIC LIGHTS =====
    function updateTrafficLights() {
      const container = document.getElementById('trafficLights');
      const summary = document.getElementById('statusSummary');

      let healthy = 0, warning = 0, critical = 0, idle = 0, cli = 0;

      container.innerHTML = sessions.map(s => {
        const quality = s.qualityScore || 0;
        const isIdle = s.status === 'idle' || s.status === 'paused';
        const isAutonomous = s.autonomous || s.isAutonomous;

        let statusClass, tooltipText;
        if (!isAutonomous) {
          // CLI sessions don't have quality tracking
          statusClass = isIdle ? 'idle' : 'good';
          tooltipText = `${s.project}: CLI (no quality tracking)`;
          cli++;
        } else if (isIdle) {
          statusClass = 'idle';
          tooltipText = `${s.project}: Idle`;
          idle++;
        } else if (quality >= 85) {
          statusClass = 'excellent';
          tooltipText = `${s.project}: ${quality}`;
          healthy++;
        } else if (quality >= 75) {
          statusClass = 'good';
          tooltipText = `${s.project}: ${quality}`;
          healthy++;
        } else if (quality >= 50) {
          statusClass = 'warning';
          tooltipText = `${s.project}: ${quality}`;
          warning++;
        } else {
          statusClass = 'critical';
          tooltipText = `${s.project}: ${quality}`;
          critical++;
        }

        return `
          <div class="traffic-light ${statusClass}" onclick="selectSession('${s.id}')" title="${s.project}">
            <div class="traffic-light-tooltip">${tooltipText}</div>
          </div>
        `;
      }).join('');

      // Build summary - only show quality counts for autonomous sessions
      const parts = [];
      if (healthy) parts.push(`${healthy} healthy`);
      if (warning) parts.push(`${warning} warning`);
      if (critical) parts.push(`${critical} critical`);
      if (idle) parts.push(`${idle} idle`);
      if (cli) parts.push(`${cli} CLI`);

      // If all sessions are CLI, indicate no quality tracking
      if (cli === sessions.length && sessions.length > 0) {
        summary.textContent = `${sessions.length} CLI sessions (no quality tracking)`;
      } else {
        summary.textContent = `${sessions.length} sessions: ${parts.join(', ') || 'none'}`;
      }
    }

    // ===== SESSION LIST =====
    // Track collapsed groups
    const collapsedGroups = new Set();

    // Throttle UI updates to prevent jumping
    let lastUIUpdate = 0;
    const UI_UPDATE_THROTTLE = 500; // ms
    let pendingUIUpdate = null;

    function throttledUIUpdate() {
      const now = Date.now();
      if (now - lastUIUpdate >= UI_UPDATE_THROTTLE) {
        lastUIUpdate = now;
        updateTrafficLights();
        updateSessionList();
        if (selectedSessionId) {
          updateDetailPanel();
        }
      } else if (!pendingUIUpdate) {
        pendingUIUpdate = setTimeout(() => {
          pendingUIUpdate = null;
          lastUIUpdate = Date.now();
          updateTrafficLights();
          updateSessionList();
          if (selectedSessionId) {
            updateDetailPanel();
          }
        }, UI_UPDATE_THROTTLE - (now - lastUIUpdate));
      }
    }

    function toggleGroup(project) {
      if (collapsedGroups.has(project)) {
        collapsedGroups.delete(project);
      } else {
        collapsedGroups.add(project);
      }
      updateSessionList();
    }

    function renderSessionItem(s) {
      const quality = s.qualityScore || 0;
      const isIdle = s.status === 'idle' || s.status === 'paused';
      const isAutonomous = s.autonomous || s.isAutonomous;
      const isSelected = s.id === selectedSessionId;

      // CLI sessions don't have quality tracking - show NA
      let qualityClass;
      let qualityDisplay;
      if (!isAutonomous) {
        qualityClass = 'idle';
        qualityDisplay = 'NA';
      } else if (isIdle) {
        qualityClass = 'idle';
        qualityDisplay = '--';
      } else if (quality >= 85) {
        qualityClass = 'excellent';
        qualityDisplay = quality;
      } else if (quality >= 75) {
        qualityClass = 'good';
        qualityDisplay = quality;
      } else if (quality >= 50) {
        qualityClass = 'warning';
        qualityDisplay = quality;
      } else {
        qualityClass = 'critical';
        qualityDisplay = quality;
      }

      let borderClass = '';
      if (isAutonomous && !isIdle && quality < 50) borderClass = 'critical';
      else if (isAutonomous && !isIdle && quality < 75) borderClass = 'warning';

      // Format session ID for display
      const sessionIdShort = s.cliSessionId || (s.registryId ? `#${s.registryId}` : '');
      const sessionTypeLabel = isAutonomous ? 'AUTO' : 'CLI';
      const sessionTypeBadgeClass = isAutonomous ? 'autonomous' : 'cli';

      // Format time
      const timeAgo = s.lastUpdate ? formatTimeAgo(s.lastUpdate) : '';

      // Phase 4: Use claimed task for per-session display
      // Priority: claimedTaskId > currentTask.id > next in queue
      const claimedTaskId = s.claimedTaskId;
      const claimInfo = s.claimInfo;
      const claimIsStale = claimInfo && isClaimStale(claimInfo);

      // Determine what task to show for this session
      let taskDisplay = '';
      let claimIndicator = '';

      if (claimedTaskId) {
        // Session has a claimed task
        taskDisplay = claimedTaskId;
        if (claimIsStale) {
          claimIndicator = '<span class="claim-indicator stale" title="Claim may be stale">⚠</span>';
        } else {
          claimIndicator = '<span class="claim-indicator owned" title="Claimed by this session">✓</span>';
        }
      } else if (s.currentTask?.id) {
        // Fall back to currentTask from project data
        taskDisplay = s.currentTask.id;
      } else if (s.taskQueue?.length) {
        taskDisplay = `Next: ${s.taskQueue[0].id}`;
      } else {
        taskDisplay = 'No active task';
      }

      const taskPhase = s.currentTask?.phase || s.phase;

      return `
        <div class="session-item ${borderClass} ${isSelected ? 'selected' : ''}"
             onclick="selectSession('${s.id}')"
             role="option"
             tabindex="0"
             aria-selected="${isSelected}"
             aria-label="${s.project} ${sessionTypeLabel} session, quality ${qualityDisplay}"
             onkeydown="if(event.key==='Enter'||event.key===' ')selectSession('${s.id}')">
          <div class="session-header">
            <span class="session-name">
              <span class="session-type-badge ${sessionTypeBadgeClass}">${sessionTypeLabel}</span>
              ${s.project}
            </span>
            <span class="quality-badge ${qualityClass}" aria-label="Quality score ${qualityDisplay}">${qualityDisplay}</span>
          </div>
          <div class="session-task">
            ${taskDisplay}${claimIndicator}
            ${taskPhase ? `<span class="phase-badge ${taskPhase}">${taskPhase}</span>` : ''}
            ${s.iteration > 1 ? `<span style="font-size:10px;color:var(--text-muted)">iter ${s.iteration}</span>` : ''}
          </div>
          <div class="session-metrics">
            <span class="session-id-text" title="Session ID">${sessionIdShort}</span>
            <span title="Context used">${Math.round(s.contextPercent || 0)}% ctx</span>
            ${s.taskStats?.total ? `<span title="Task completion">${s.taskStats.byStatus?.completed || 0}/${s.taskStats.total} tasks</span>` : ''}
            ${timeAgo ? `<span title="Last update">${timeAgo}</span>` : ''}
            ${settings.showCost ? `<span title="Cost">$${(s.cost || 0).toFixed(2)}</span>` : ''}
          </div>
          <div class="session-controls" onclick="event.stopPropagation()">
            <button class="control-btn pause" onclick="togglePause('${s.id}')" aria-label="${s.status === 'paused' ? 'Resume session' : 'Pause session'}">
              ${s.status === 'paused' ? '▶' : '⏸'}
            </button>
            <button class="control-btn skip" onclick="skipTask('${s.id}')" aria-label="Skip current task">⏭</button>
            <button class="control-btn end" onclick="endSession('${s.id}')" aria-label="End session">⏹</button>
          </div>
        </div>
      `;
    }

    function formatTimeAgo(timestamp) {
      if (!timestamp) return '';
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return `${seconds}s ago`;
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    function updateSessionList() {
      const container = document.getElementById('sessionItems');
      const countEl = document.getElementById('sessionCount');

      // Preserve scroll position
      const scrollTop = container.scrollTop;

      // Get filter settings
      const activeOnly = document.getElementById('filterActiveOnly')?.checked ?? false;
      const showCli = document.getElementById('filterShowCli')?.checked ?? true;
      const showAuto = document.getElementById('filterShowAuto')?.checked ?? true;
      const groupByProject = document.getElementById('filterGroupByProject')?.checked ?? true;

      // Apply filters and sort (active first, then by most recent)
      const filteredSessions = sessions.filter(s => {
        const isActive = s.status === 'active';
        const isAutonomous = s.autonomous || s.isAutonomous;

        if (activeOnly && !isActive) return false;
        if (!showCli && !isAutonomous) return false;
        if (!showAuto && isAutonomous) return false;

        return true;
      }).sort((a, b) => {
        // Active first, then by most recent
        const aActive = a.status === 'active' ? 1 : 0;
        const bActive = b.status === 'active' ? 1 : 0;
        if (aActive !== bActive) return bActive - aActive;
        return (b.lastUpdate || 0) - (a.lastUpdate || 0);
      });

      // Time thresholds for activity
      const now = Date.now();
      const thirtyMinsAgo = now - (30 * 60 * 1000);
      const tenMinsAgo = now - (10 * 60 * 1000);

      if (groupByProject) {
        // Group sessions by project
        const groups = {};
        for (const s of filteredSessions) {
          const key = s.project || 'Unknown';
          if (!groups[key]) groups[key] = [];
          groups[key].push(s);
        }

        // Filter to only active projects (has session active in last 30 mins)
        const activeGroups = Object.entries(groups).filter(([, projectSessions]) => {
          return projectSessions.some(s => (s.lastUpdate || 0) > thirtyMinsAgo);
        });

        // Sort groups by: has active session, then by most recent update in group
        const sortedGroups = activeGroups.sort(([, sessionsA], [, sessionsB]) => {
          const aHasActive = sessionsA.some(s => s.status === 'active') ? 1 : 0;
          const bHasActive = sessionsB.some(s => s.status === 'active') ? 1 : 0;
          if (aHasActive !== bHasActive) return bHasActive - aHasActive;
          const aMaxUpdate = Math.max(...sessionsA.map(s => s.lastUpdate || 0));
          const bMaxUpdate = Math.max(...sessionsB.map(s => s.lastUpdate || 0));
          return bMaxUpdate - aMaxUpdate;
        });

        // Count visible sessions
        let visibleCount = 0;

        // Render grouped
        container.innerHTML = sortedGroups.map(([project, projectSessions]) => {
          // Within active projects, only show sessions active in last 10 mins
          const recentSessions = projectSessions.filter(s => (s.lastUpdate || 0) > tenMinsAgo);
          const hiddenCount = projectSessions.length - recentSessions.length;

          visibleCount += recentSessions.length;

          // Skip if no recent sessions (shouldn't happen since project is active)
          if (recentSessions.length === 0) return '';

          const activeCount = recentSessions.filter(s => s.status === 'active').length;

          // Only collapse if user manually collapsed it
          const isCollapsed = collapsedGroups.has(project);

          return `
            <div class="session-group ${isCollapsed ? 'collapsed' : ''}">
              <div class="session-group-header" onclick="toggleGroup('${project}')">
                <span class="session-group-toggle">▼</span>
                <span>${project}</span>
                <span class="session-group-count">${activeCount > 0 ? `${activeCount} active` : 'idle'}${hiddenCount > 0 ? ` (+${hiddenCount} older)` : ''}</span>
              </div>
              <div class="session-group-items">
                ${recentSessions.map(s => renderSessionItem(s)).join('')}
              </div>
            </div>
          `;
        }).join('');

        countEl.textContent = `${visibleCount}/${sessions.length}`;
      } else {
        // Render flat list - only show sessions active in last 10 mins
        const recentSessions = filteredSessions.filter(s => (s.lastUpdate || 0) > tenMinsAgo);
        container.innerHTML = recentSessions.map(s => renderSessionItem(s)).join('');
        countEl.textContent = `${recentSessions.length}/${sessions.length}`;
      }

      // Restore scroll position
      container.scrollTop = scrollTop;
    }

    // ===== DETAIL PANEL =====
    function selectSession(id) {
      selectedSessionId = id;
      updateSessionList(); // Update selection highlight
      updateDetailPanel();
    }

    function updateDetailPanel() {
      const session = sessions.find(s => s.id === selectedSessionId);
      const emptyEl = document.getElementById('detailEmpty');
      const contentEl = document.getElementById('detailContent');

      if (!session) {
        emptyEl.style.display = 'flex';
        contentEl.style.display = 'none';
        return;
      }

      // Preserve scroll positions and log content
      const detailContentEl = contentEl.querySelector('.detail-content');
      const detailScrollTop = detailContentEl ? detailContentEl.scrollTop : 0;
      const logContentEl = document.getElementById('logContent');
      const logScrollTop = logContentEl ? logContentEl.scrollTop : 0;
      const logWasAtBottom = logContentEl ? (logContentEl.scrollHeight - logContentEl.scrollTop <= logContentEl.clientHeight + 50) : true;
      // Preserve log content HTML to avoid losing "No logs" message on panel refresh
      const preservedLogContent = logContentEl ? logContentEl.innerHTML : null;

      emptyEl.style.display = 'none';
      contentEl.style.display = 'flex';

      const quality = session.qualityScore || 0;
      const isIdle = session.status === 'idle' || session.status === 'paused';
      const prediction = predictions[session.project] || {};
      const isAutonomous = session.autonomous || session.isAutonomous;

      // CLI sessions don't have quality tracking - show NA
      let qualityClass = 'health';
      let qualityDisplay;
      if (!isAutonomous) {
        qualityDisplay = 'NA';
      } else if (isIdle) {
        qualityDisplay = '--';
      } else {
        qualityDisplay = quality;
        if (quality < 50) qualityClass = 'critical';
        else if (quality < 75) qualityClass = 'warning';
      }

      // Build quality breakdown tooltip
      const qualityBreakdown = session.qualityBreakdown || {};
      const breakdownText = isAutonomous ? Object.entries(qualityBreakdown)
        .map(([k, v]) => `${k}: ${v}`)
        .join(', ') : 'Quality tracking only available for autonomous sessions';

      const metricsHTML = `
        <div class="metric-card ${qualityClass}">
          <div class="metric-label">Quality Score</div>
          <div class="metric-value ${isAutonomous && quality >= 75 ? 'success' : isAutonomous && quality >= 50 ? 'warning' : ''}"
               title="${breakdownText}">
            ${qualityDisplay}
          </div>
          ${isAutonomous && breakdownText && Object.keys(qualityBreakdown).length ? `<div class="metric-detail" style="font-size:10px;max-width:150px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${breakdownText}">${Object.keys(qualityBreakdown).length} criteria scored</div>` : ''}
        </div>
        <div class="metric-card">
          <div class="metric-label">Context Used</div>
          <div class="metric-value">${Math.round(session.contextPercent || 0)}%</div>
          ${settings.showExhaustionETA && prediction.minutesToExhaustion
            ? `<div class="metric-detail">Exhaustion in ~${prediction.minutesToExhaustion}m</div>`
            : `<div class="metric-detail">${session.tokens ? (session.tokens/1000).toFixed(1) + 'k tokens' : 'Healthy pace'}</div>`}
        </div>
        <div class="metric-card">
          <div class="metric-label">Phase / Iteration</div>
          <div class="metric-value" style="font-size: 18px;">${session.phase || session.currentTask?.phase || 'Idle'}</div>
          <div class="metric-detail">Iteration ${session.iteration || 1}</div>
        </div>
        <div class="metric-card">
          <div class="metric-label">Task Progress</div>
          <div class="metric-value" style="font-size: 18px;">${session.taskStats?.byStatus?.completed || 0}/${session.taskStats?.total || 0}</div>
          <div class="metric-detail">${session.taskQueue?.length || 0} ready, ${session.taskStats?.byStatus?.blocked || 0} blocked</div>
        </div>
      `;

      const task = session.currentTask || {};
      const acceptance = task.acceptance || [];
      const completedCriteria = acceptance.filter(a => a.done).length;

      const taskHTML = task.id ? `
        <div class="task-card">
          <div class="task-header">
            <span class="task-title">${task.title || task.id}</span>
            <span class="phase-badge ${task.phase || ''}">${task.phase || 'unknown'}</span>
          </div>
          <div class="task-meta">
            <span>Priority: ${task.priority || 'normal'}</span>
            <span>Estimate: ${task.estimate || '--'}</span>
            ${settings.showErrorCount ? `<span>Attempts: ${task.attempts || 1}</span>` : ''}
          </div>
          ${renderPhaseProgression(task.id, task.phase)}
          ${settings.showAcceptanceProgress ? `
          <ul class="acceptance-list">
            ${acceptance.map(a => `
              <li class="acceptance-item ${a.done ? 'done' : ''}">
                <span class="check">${a.done ? '✓' : ''}</span>
                ${a.text || a}
              </li>
            `).join('')}
          </ul>
          ` : ''}
        </div>
      ` : '<div class="task-card" style="text-align: center; color: var(--text-muted);">No active task</div>';

      const queue = session.taskQueue || [];
      const sessionRegistryId = session.registryId || session.cliSessionId || session.id;

      // Render queue with claim badges
      const queueHTML = queue.length ? `
        <div class="queue-filters">
          <button class="queue-filter-btn ${queueFilter === 'all' ? 'active' : ''}" onclick="setQueueFilter('all')">All</button>
          <button class="queue-filter-btn ${queueFilter === 'available' ? 'active' : ''}" onclick="setQueueFilter('available')">Available</button>
          <button class="queue-filter-btn ${queueFilter === 'claimed' ? 'active' : ''}" onclick="setQueueFilter('claimed')">Claimed</button>
          <button class="queue-filter-btn ${queueFilter === 'mine' ? 'active' : ''}" onclick="setQueueFilter('mine')">Mine</button>
        </div>
        <div class="queue-list">
          ${queue.slice(0, 8).map((t, i) => {
            const claimStatus = getClaimStatus(t.id, sessionRegistryId);
            const claimClass = claimStatus.status === 'mine' ? 'claimed-by-me' :
                               claimStatus.status === 'stale' ? 'stale-claim' :
                               claimStatus.status === 'claimed' ? 'claimed' : '';

            // Apply filter
            if (queueFilter === 'available' && claimStatus.status !== 'available') return '';
            if (queueFilter === 'claimed' && claimStatus.status === 'available') return '';
            if (queueFilter === 'mine' && claimStatus.status !== 'mine') return '';

            const claimBadge = renderClaimBadge(claimStatus);

            return `
            <div class="queue-item ${i === 0 ? 'next' : ''} ${claimClass}">
              <span class="queue-number">${i + 1}</span>
              <span class="queue-task" title="${t.title || t.id}">
                ${t.id}
                ${t.phase ? '<span class="phase-badge ' + t.phase + '" style="margin-left:6px">' + t.phase + '</span>' : ''}
              </span>
              ${claimBadge}
              <span class="queue-priority ${t.priority || ''}">${t.priority || 'normal'}</span>
            </div>
          `;}).filter(Boolean).join('')}
          ${queue.length > 8 ? '<div class="queue-item" style="justify-content:center;color:var(--text-muted)">+' + (queue.length - 8) + ' more</div>' : ''}
        </div>
        <div class="claim-stats">
          <span class="claim-stat"><span class="claim-stat-dot available"></span>${queue.filter(t => !getClaimForTask(t.id)).length} available</span>
          <span class="claim-stat"><span class="claim-stat-dot claimed"></span>${queue.filter(t => getClaimForTask(t.id)).length} claimed</span>
        </div>
      ` : '<div style="color: var(--text-muted); text-align: center; padding: 20px;">No tasks in queue. All caught up!</div>';

      contentEl.innerHTML = `
        <div class="detail-header">
          <div class="detail-title">
            ${session.project}
            ${isAutonomous ? '<span title="Autonomous Session">🤖</span>' : ''}
          </div>
          <div class="detail-actions">
            <button class="detail-btn" onclick="togglePause('${session.id}')">
              ${session.status === 'paused' ? 'Resume' : 'Pause'}
            </button>
            <button class="detail-btn" onclick="skipTask('${session.id}')">Skip Task</button>
            <button class="detail-btn danger" onclick="endSession('${session.id}')">End Session</button>
          </div>
        </div>

        <div class="metrics-grid">
          ${metricsHTML}
        </div>

        <div class="detail-content">
          <div class="detail-section">
            <h3>Current Task</h3>
            ${taskHTML}
          </div>

          <div class="detail-section">
            <h3>Task Queue</h3>
            ${queueHTML}
          </div>

          <div class="detail-section">
            <h3>Agent Hierarchy</h3>
            <div class="hierarchy-panel">
              <div class="hierarchy-panel-header">
                <span class="hierarchy-panel-title">Delegation Tree</span>
                <div class="hierarchy-panel-actions">
                  <button onclick="expandAllHierarchy()">Expand</button>
                  <button onclick="collapseAllHierarchy()">Collapse</button>
                  <button onclick="refreshHierarchy('${session.id}')">Refresh</button>
                </div>
              </div>
              <div class="hierarchy-panel-body" id="hierarchyTreeContainer">
                <div class="hierarchy-empty">
                  <div class="hierarchy-empty-icon">Loading...</div>
                </div>
              </div>
            </div>
          </div>

          <div class="detail-section">
            <h3>Lessons Learned</h3>
            <div class="lessons-section" id="lessonsSection">
              <div class="lessons-header" onclick="toggleLessons()">
                <span class="lessons-title">Session Notes & Learnings</span>
                <span class="lessons-count" id="lessonsCount">0 notes</span>
                <span id="lessonsToggleIcon">▼</span>
              </div>
              <div class="lessons-content" id="lessonsContent" style="display: none;">
                <div class="lessons-empty">No lessons recorded yet</div>
              </div>
            </div>
          </div>

          <div class="detail-section">
            <h3>Live Logs</h3>
            <div class="log-section">
              <div class="log-header" onclick="toggleLogs()">
                <span class="log-title">
                  <span class="log-streaming-dot"></span>
                  Session Logs
                </span>
                <span id="logToggleIcon">▼</span>
              </div>
              <div class="log-content" id="logContent">
                <div class="log-line info">[${new Date().toLocaleTimeString()}] Connected to session...</div>
              </div>
            </div>
          </div>
        </div>
      `;

      // Start log streaming for selected session (only if session changed)
      // Use logSessionId if available (maps to actual log file), fallback to session.id
      const logId = session.logSessionId != null ? session.logSessionId : session.id;
      const sessionChanged = logId && (!logEventSource || logEventSource.sessionId !== logId);

      // Restore scroll positions and log content after DOM update
      requestAnimationFrame(() => {
        const newDetailContent = contentEl.querySelector('.detail-content');
        if (newDetailContent && detailScrollTop > 0) {
          newDetailContent.scrollTop = detailScrollTop;
        }
        const newLogContent = document.getElementById('logContent');
        if (newLogContent) {
          // If session didn't change and we have preserved content, restore it
          if (!sessionChanged && preservedLogContent) {
            newLogContent.innerHTML = preservedLogContent;
          }
          if (logWasAtBottom) {
            // If was at bottom, stay at bottom (for auto-scroll)
            newLogContent.scrollTop = newLogContent.scrollHeight;
          } else if (logScrollTop > 0) {
            newLogContent.scrollTop = logScrollTop;
          }
        }
      });

      // Only start log stream if session changed
      if (sessionChanged) {
        startLogStream(logId);
      }

      // Load hierarchy for selected session
      loadHierarchy(session.id);
    }

    // ===== USAGE DISPLAY =====
    function updateUsageDisplay() {
      const fiveHour = usageLimits.fiveHour || {};
      const daily = usageLimits.daily || {};
      const weekly = usageLimits.weekly || {};

      // Main badge
      const mainPercent = fiveHour.percent || 0;
      document.getElementById('usagePercent').textContent = `${mainPercent}%`;
      const fillEl = document.getElementById('usageBarFill');
      fillEl.style.width = `${mainPercent}%`;
      fillEl.className = 'bar-fill' + (mainPercent >= 90 ? ' critical' : mainPercent >= 75 ? ' warning' : '');

      // 5-hour
      document.getElementById('usage5h').textContent = `${fiveHour.used || 0}/${fiveHour.limit || 300}`;
      const fill5h = document.getElementById('usage5hFill');
      fill5h.style.width = `${fiveHour.percent || 0}%`;
      fill5h.className = 'usage-limit-fill' + (fiveHour.percent >= 90 ? ' critical' : fiveHour.percent >= 75 ? ' warning' : '');
      document.getElementById('usage5hMeta').textContent = `Resets in ${fiveHour.resetIn || '--'}`;

      // Daily
      document.getElementById('usageDaily').textContent = `${daily.used || 0}/${daily.limit || 1500}`;
      const fillDaily = document.getElementById('usageDailyFill');
      fillDaily.style.width = `${daily.percent || 0}%`;
      fillDaily.className = 'usage-limit-fill' + (daily.percent >= 90 ? ' critical' : daily.percent >= 75 ? ' warning' : '');
      document.getElementById('usageDailyMeta').textContent = `Resets in ${daily.resetIn || '--'}`;

      // Weekly
      document.getElementById('usageWeekly').textContent = `${weekly.used || 0}/${weekly.limit || 7000}`;
      const fillWeekly = document.getElementById('usageWeeklyFill');
      fillWeekly.style.width = `${weekly.percent || 0}%`;
      fillWeekly.className = 'usage-limit-fill' + (weekly.percent >= 90 ? ' critical' : weekly.percent >= 75 ? ' warning' : '');
      document.getElementById('usageWeeklyMeta').textContent = `Resets on ${weekly.resetDay || '--'}`;
    }

    // ===== SESSION CONTROLS =====
    async function togglePause(id) {
      const session = sessions.find(s => s.id === id);
      if (!session) return;

      const action = session.status === 'paused' ? 'resume' : 'pause';
      try {
        await fetch(`/api/sessions/${id}/${action}`, { method: 'POST' });
        fetchSessions();
      } catch (err) {
        console.error(`Failed to ${action} session:`, err);
      }
    }

    async function skipTask(id) {
      if (!confirm('Skip current task and move to next?')) return;
      try {
        await fetch(`/api/sessions/${id}/skip-task`, { method: 'POST' });
        fetchSessions();
      } catch (err) {
        console.error('Failed to skip task:', err);
      }
    }

    async function endSession(id) {
      if (!confirm('End this session? This cannot be undone.')) return;
      try {
        await fetch(`/api/sessions/${id}/end`, { method: 'POST' });
        if (selectedSessionId === id) {
          selectedSessionId = null;
        }
        fetchSessions();
      } catch (err) {
        console.error('Failed to end session:', err);
      }
    }

    // ===== LOG STREAMING =====
    let logEventSource = null;

    async function startLogStream(sessionId) {
      if (logEventSource) {
        logEventSource.close();
        logEventSource = null;
      }

      const logContent = document.getElementById('logContent');
      if (!logContent) return;

      // Clear existing logs
      logContent.innerHTML = '';

      // First, fetch historical logs
      let hasLogs = false;
      try {
        const historyRes = await fetch(`/api/logs/${sessionId}/history?lines=50`);
        if (historyRes.ok) {
          const history = await historyRes.json();
          if (history.entries && history.entries.length > 0) {
            hasLogs = true;
            history.entries.forEach(entry => {
              const line = document.createElement('div');
              line.className = 'log-line ' + (entry.level || '').toLowerCase();
              line.textContent = `[${entry.timestamp || ''}] ${entry.line || entry.raw || ''}`;
              logContent.appendChild(line);
            });
            logContent.scrollTop = logContent.scrollHeight;
          }
        }
      } catch (err) {
        console.log('No historical logs available');
      }

      // If no logs found, show helpful message
      if (!hasLogs) {
        const msg = document.createElement('div');
        msg.className = 'log-line info';
        msg.style.color = '#888';
        msg.style.fontStyle = 'italic';
        msg.innerHTML = 'No session logs available.<br><span style="font-size: 11px;">Logs appear when running the autonomous orchestrator (npm run autonomous)</span>';
        logContent.appendChild(msg);
      }

      // Then start SSE stream for new logs
      logEventSource = new EventSource(`/api/logs/${sessionId}/stream`);
      logEventSource.sessionId = sessionId;

      logEventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          // If we showed the "no logs" message, clear it
          if (!hasLogs && logContent.children.length === 1) {
            logContent.innerHTML = '';
            hasLogs = true;
          }
          const line = document.createElement('div');
          line.className = 'log-line ' + (data.level || '').toLowerCase();
          line.textContent = `[${new Date(data.timestamp).toLocaleTimeString()}] ${data.line || data.message}`;
          logContent.appendChild(line);
          logContent.scrollTop = logContent.scrollHeight;

          // Keep only last 100 lines
          while (logContent.children.length > 100) {
            logContent.removeChild(logContent.firstChild);
          }
        } catch (err) {
          // Ignore parse errors
        }
      };
    }

    function toggleLogs() {
      const content = document.getElementById('logContent');
      const icon = document.getElementById('logToggleIcon');
      if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.textContent = '▲';
      } else {
        content.style.display = 'none';
        icon.textContent = '▼';
      }
    }

    function toggleLessons() {
      const content = document.getElementById('lessonsContent');
      const icon = document.getElementById('lessonsToggleIcon');
      if (content.style.display === 'none') {
        content.style.display = 'block';
        icon.textContent = '▲';
        fetchLessons();
      } else {
        content.style.display = 'none';
        icon.textContent = '▼';
      }
    }

    async function fetchLessons() {
      if (!selectedSessionId) return;

      const session = sessions.find(s => s.id === selectedSessionId);
      if (!session) return;

      try {
        // Fetch lessons from memory store or task notes
        const res = await fetch(`/api/lessons/${session.project}`);
        if (!res.ok) {
          // If endpoint doesn't exist, show placeholder
          updateLessonsUI([]);
          return;
        }
        const data = await res.json();
        // API returns { projectId, lessons, count }
        updateLessonsUI(data.lessons || []);
      } catch (err) {
        // Endpoint may not exist yet - show placeholder
        updateLessonsUI([]);
      }
    }

    function updateLessonsUI(lessons) {
      const content = document.getElementById('lessonsContent');
      const count = document.getElementById('lessonsCount');

      if (!lessons || lessons.length === 0) {
        content.innerHTML = '<div class="lessons-empty">No lessons recorded yet. Notes will appear here as tasks complete.</div>';
        count.textContent = '0 notes';
        return;
      }

      count.textContent = `${lessons.length} note${lessons.length !== 1 ? 's' : ''}`;

      content.innerHTML = lessons.map(lesson => {
        const typeClass = lesson.type === 'success' ? 'success' :
                          lesson.type === 'warning' ? 'warning' :
                          lesson.type === 'error' ? 'error' : '';

        const timeAgo = getTimeAgo(new Date(lesson.timestamp));

        return `
          <div class="lesson-item ${typeClass}">
            <div class="lesson-task">
              <span>${lesson.taskId || 'General'}</span>
              <span>${timeAgo}</span>
            </div>
            <div class="lesson-text">${lesson.text || lesson.note}</div>
            ${lesson.tags ? `
              <div class="lesson-tags">
                ${lesson.tags.map(t => `<span class="lesson-tag">${t}</span>`).join('')}
              </div>
            ` : ''}
          </div>
        `;
      }).join('');
    }

    function getTimeAgo(date) {
      const seconds = Math.floor((new Date() - date) / 1000);
      if (seconds < 60) return 'just now';
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h ago`;
      const days = Math.floor(hours / 24);
      return `${days}d ago`;
    }

    // ===== UI HELPERS =====
    function toggleUsageDropdown() {
      const dropdown = document.getElementById('usageDropdown');
      const button = dropdown.previousElementSibling;
      const isOpen = dropdown.classList.toggle('open');
      button.setAttribute('aria-expanded', isOpen);
    }

    function toggleSettings() {
      const modal = document.getElementById('settingsModal');
      modal.classList.toggle('open');
    }

    function toggleSetting(el) {
      el.classList.toggle('active');
      const setting = el.dataset.setting;
      settings[setting] = el.classList.contains('active');
      localStorage.setItem('dashboardSettings', JSON.stringify(settings));

      // Re-render affected components
      updateSessionList();
      if (selectedSessionId) {
        updateDetailPanel();
      }
    }

    function loadSettingsUI() {
      document.querySelectorAll('.toggle[data-setting]').forEach(el => {
        const setting = el.dataset.setting;
        if (settings[setting]) {
          el.classList.add('active');
        } else {
          el.classList.remove('active');
        }
      });
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.usage-badge') && !e.target.closest('.usage-dropdown')) {
        document.getElementById('usageDropdown').classList.remove('open');
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT') return;

      const sessionList = sessions;
      const currentIndex = sessionList.findIndex(s => s.id === selectedSessionId);

      switch (e.key) {
        case 'j': // Next session
          if (currentIndex < sessionList.length - 1) {
            selectSession(sessionList[currentIndex + 1].id);
          } else if (sessionList.length > 0) {
            selectSession(sessionList[0].id);
          }
          break;
        case 'k': // Previous session
          if (currentIndex > 0) {
            selectSession(sessionList[currentIndex - 1].id);
          } else if (sessionList.length > 0) {
            selectSession(sessionList[sessionList.length - 1].id);
          }
          break;
        case 'p': // Pause/Resume
          if (selectedSessionId) togglePause(selectedSessionId);
          break;
        case 's': // Skip task
          if (selectedSessionId) skipTask(selectedSessionId);
          break;
        case 'Escape':
          selectedSessionId = null;
          updateSessionList();
          document.getElementById('detailEmpty').style.display = 'flex';
          document.getElementById('detailContent').style.display = 'none';
          break;
        case '?':
          alert('Keyboard Shortcuts:\n\nj/k - Navigate sessions\np - Pause/Resume\ns - Skip task\nEsc - Deselect');
          break;
      }
    });

    // ===== HIERARCHY VISUALIZATION =====
    const HierarchyTreeState = {
      rootNode: null,
      nodeMap: new Map(),
      selectedNodeId: null,
      expandedNodeIds: new Set(),
      currentSessionId: null,

      reset() {
        this.rootNode = null;
        this.nodeMap.clear();
        this.selectedNodeId = null;
        this.expandedNodeIds.clear();
      },

      registerNode(node) {
        this.nodeMap.set(node.id, node);
      },

      getNode(nodeId) {
        return this.nodeMap.get(nodeId);
      }
    };

    async function loadHierarchy(sessionId) {
      if (!sessionId) return;
      HierarchyTreeState.currentSessionId = sessionId;
      HierarchyTreeState.reset();

      const container = document.getElementById('hierarchyTreeContainer');
      if (!container) return;

      container.innerHTML = '<div class="hierarchy-empty"><div class="hierarchy-empty-icon">Loading...</div></div>';

      try {
        const response = await fetch(`/api/sessions/${encodeURIComponent(sessionId)}/hierarchy`);

        if (!response.ok) {
          if (response.status === 404) {
            container.innerHTML = '<div class="hierarchy-empty"><div class="hierarchy-empty-icon">No delegation data</div></div>';
            return;
          }
          throw new Error(`API error: ${response.status}`);
        }

        const hierarchyData = await response.json();
        const rootNode = transformHierarchyData(hierarchyData, null, 0);

        HierarchyTreeState.rootNode = rootNode;
        HierarchyTreeState.expandedNodeIds.add(rootNode.id);

        renderHierarchyTree(container);
      } catch (error) {
        console.error('Failed to load hierarchy:', error);
        container.innerHTML = `<div class="hierarchy-empty"><div class="hierarchy-empty-icon">Error loading hierarchy</div></div>`;
      }
    }

    function transformHierarchyData(apiNode, parentId, depth) {
      const node = {
        id: apiNode.id || apiNode.agentId || `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        name: apiNode.name || apiNode.persona || apiNode.agentId || 'Unknown Agent',
        type: apiNode.type || (depth === 0 ? 'root' : 'agent'),
        status: normalizeHierarchyStatus(apiNode.status),
        children: [],
        parentId: parentId,
        depth: depth,
        metrics: {
          tokensUsed: apiNode.metrics?.tokensUsed || 0,
          qualityScore: apiNode.metrics?.qualityScore || 0,
          durationMs: apiNode.metrics?.durationMs || 0
        }
      };

      HierarchyTreeState.registerNode(node);

      const childNodes = apiNode.children || apiNode.delegates || apiNode.subAgents || [];
      node.children = childNodes.map(child => transformHierarchyData(child, node.id, depth + 1));

      return node;
    }

    function normalizeHierarchyStatus(status) {
      const statusMap = {
        'running': 'active', 'in_progress': 'active',
        'success': 'completed', 'done': 'completed',
        'error': 'failed', 'waiting': 'pending', 'queued': 'pending'
      };
      return statusMap[status] || status || 'idle';
    }

    function renderHierarchyTree(container) {
      if (!HierarchyTreeState.rootNode) {
        container.innerHTML = '<div class="hierarchy-empty"><div class="hierarchy-empty-icon">No hierarchy data</div></div>';
        return;
      }

      const treeHtml = renderHierarchyNode(HierarchyTreeState.rootNode);
      container.innerHTML = `<div class="hierarchy-tree">${treeHtml}</div>`;
      attachHierarchyEvents(container);
    }

    function renderHierarchyNode(node) {
      const hasChildren = node.children && node.children.length > 0;
      const isExpanded = HierarchyTreeState.expandedNodeIds.has(node.id);
      const isSelected = HierarchyTreeState.selectedNodeId === node.id;

      const nodeClasses = [
        'hierarchy-tree__node',
        `hierarchy-tree__node--${node.type}`,
        `hierarchy-tree__node--${node.status}`,
        hasChildren ? 'hierarchy-tree__node--has-children' : '',
        isExpanded ? 'hierarchy-tree__node--expanded' : '',
        isSelected ? 'hierarchy-tree__node--selected' : ''
      ].filter(Boolean).join(' ');

      const icons = { root: '&#x1F3E0;', session: '&#x1F4CB;', agent: '&#x1F916;' };
      const icon = icons[node.type] || '&#x1F4C4;';

      return `
        <div class="${nodeClasses}" data-node-id="${escapeHtmlAttr(node.id)}" data-depth="${node.depth}">
          <div class="hierarchy-tree__node-row">
            ${hasChildren ? `
              <button class="hierarchy-tree__toggle" data-action="toggle" data-node-id="${escapeHtmlAttr(node.id)}">
                ${isExpanded ? '&#9660;' : '&#9654;'}
              </button>
            ` : '<span class="hierarchy-tree__toggle-placeholder"></span>'}
            <span class="hierarchy-tree__status-dot hierarchy-tree__status-dot--${node.status}"></span>
            <span class="hierarchy-tree__icon">${icon}</span>
            <span class="hierarchy-tree__name" data-action="select" data-node-id="${escapeHtmlAttr(node.id)}">${escapeHtmlContent(node.name)}</span>
            ${node.metrics.tokensUsed > 0 ? `<span class="hierarchy-tree__metric" title="Tokens">${formatTokens(node.metrics.tokensUsed)}</span>` : ''}
            ${hasChildren ? `<span class="hierarchy-tree__badge">${node.children.length}</span>` : ''}
          </div>
          ${hasChildren ? `
            <div class="hierarchy-tree__children" style="display: ${isExpanded ? 'block' : 'none'}">
              ${node.children.map(child => renderHierarchyNode(child)).join('')}
            </div>
          ` : ''}
        </div>
      `;
    }

    function escapeHtmlAttr(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function escapeHtmlContent(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function formatTokens(num) {
      if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
      if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
      return num.toString();
    }

    function attachHierarchyEvents(container) {
      container.addEventListener('click', (e) => {
        const target = e.target.closest('[data-action]');
        if (!target) return;

        const action = target.dataset.action;
        const nodeId = target.dataset.nodeId;
        if (!nodeId) return;

        if (action === 'toggle') {
          toggleHierarchyNode(nodeId);
        } else if (action === 'select') {
          selectHierarchyNode(nodeId);
        }
      });
    }

    function toggleHierarchyNode(nodeId) {
      const node = HierarchyTreeState.getNode(nodeId);
      if (!node || !node.children || node.children.length === 0) return;

      const isExpanded = HierarchyTreeState.expandedNodeIds.has(nodeId);
      if (isExpanded) {
        HierarchyTreeState.expandedNodeIds.delete(nodeId);
      } else {
        HierarchyTreeState.expandedNodeIds.add(nodeId);
      }

      const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
      if (nodeEl) {
        nodeEl.classList.toggle('hierarchy-tree__node--expanded', !isExpanded);
        const toggleIcon = nodeEl.querySelector('.hierarchy-tree__toggle');
        if (toggleIcon) toggleIcon.innerHTML = !isExpanded ? '&#9660;' : '&#9654;';
        const childrenEl = nodeEl.querySelector(':scope > .hierarchy-tree__children');
        if (childrenEl) childrenEl.style.display = !isExpanded ? 'block' : 'none';
      }
    }

    function selectHierarchyNode(nodeId) {
      const previousId = HierarchyTreeState.selectedNodeId;
      HierarchyTreeState.selectedNodeId = nodeId;

      if (previousId) {
        const prevEl = document.querySelector(`[data-node-id="${previousId}"]`);
        if (prevEl) prevEl.classList.remove('hierarchy-tree__node--selected');
      }

      const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
      if (nodeEl) nodeEl.classList.add('hierarchy-tree__node--selected');
    }

    function expandAllHierarchy() {
      HierarchyTreeState.nodeMap.forEach((node, id) => {
        if (node.children && node.children.length > 0 && !HierarchyTreeState.expandedNodeIds.has(id)) {
          toggleHierarchyNode(id);
        }
      });
    }

    function collapseAllHierarchy() {
      HierarchyTreeState.nodeMap.forEach((node, id) => {
        if (node.depth > 0 && HierarchyTreeState.expandedNodeIds.has(id)) {
          toggleHierarchyNode(id);
        }
      });
    }

    function refreshHierarchy(sessionId) {
      loadHierarchy(sessionId || HierarchyTreeState.currentSessionId);
    }

    // Initialize
    init();
  </script>
</body>
</html>
